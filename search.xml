<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>记一次未授权访问加逻辑缺陷通用漏洞</title>
      <link href="/2022/12/03/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E5%8A%A0%E9%80%BB%E8%BE%91%E7%BC%BA%E9%99%B7%E9%80%9A%E7%94%A8%E6%BC%8F%E6%B4%9E/"/>
      <url>/2022/12/03/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E5%8A%A0%E9%80%BB%E8%BE%91%E7%BC%BA%E9%99%B7%E9%80%9A%E7%94%A8%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h1 id="记一次未授权访问加逻辑缺陷通用漏洞"><a href="#记一次未授权访问加逻辑缺陷通用漏洞" class="headerlink" title="记一次未授权访问加逻辑缺陷通用漏洞"></a>记一次未授权访问加逻辑缺陷通用漏洞</h1><p>进入到登录界面</p><p><img src="https://blog-1258155859.cos.ap-guangzhou.myqcloud.com/image-20221203000014102.png" alt="image-20221203000014102"></p><p>首先来尝试几个弱口令</p><p><img src="https://blog-1258155859.cos.ap-guangzhou.myqcloud.com/image-20221203000055385.png" alt="image-20221203000055385"></p><p>emm</p><p>弱口令不行那试试注入</p><p><img src="https://blog-1258155859.cos.ap-guangzhou.myqcloud.com/image-20221203000342271.png" alt="image-20221203000342271"></p><p><img src="https://blog-1258155859.cos.ap-guangzhou.myqcloud.com/image-20221203000439082.png" alt="image-20221203000439082"></p><p>好像也没法注入</p><p><img src="https://blog-1258155859.cos.ap-guangzhou.myqcloud.com/0cc0506d19acf54510e88eaa329d715.jpg"></p><p>右键查看一下源码</p><p>发现一个登录成功跳转的地址</p><p><img src="https://blog-1258155859.cos.ap-guangzhou.myqcloud.com/image-20221203000713488.png" alt="image-20221203000713488"></p><p>拼接一下url</p><p>本来没报啥希望的</p><p>没想到</p><p><img src="https://blog-1258155859.cos.ap-guangzhou.myqcloud.com/image-20221203000909386.png" alt="image-20221203000909386"></p><p>直接进去了</p><p>点击一下日志</p><p><img src="https://blog-1258155859.cos.ap-guangzhou.myqcloud.com/image-20221203001216062.png" alt="image-20221203001216062"></p><p>未授权有了</p><p><img src="https://blog-1258155859.cos.ap-guangzhou.myqcloud.com/848cd2f4e9137cf16d64615ef42b015.jpg"></p><p>再测测还有没有其它漏洞</p><p><img src="https://blog-1258155859.cos.ap-guangzhou.myqcloud.com/image-20221203001424844.png" alt="image-20221203001424844"></p><p>日志页面的地址</p><p>试试再拼接一下url</p><p><img src="https://blog-1258155859.cos.ap-guangzhou.myqcloud.com/image-20221203001613778.png" alt="image-20221203001613778"></p><p>也能直接访问</p><p>继续测</p><p>在登录处输入任意的账号密码</p><p><img src="https://blog-1258155859.cos.ap-guangzhou.myqcloud.com/image-20221203001737784.png" alt="image-20221203001737784"></p><p>抓包</p><p><img src="https://blog-1258155859.cos.ap-guangzhou.myqcloud.com/image-20221203001825189.png" alt="image-20221203001825189"></p><p>然后</p><p>拦截返回包</p><p><img src="https://blog-1258155859.cos.ap-guangzhou.myqcloud.com/image-20221203001930677.png" alt="image-20221203001930677"></p><p>之前在页面源码处发现当result&#x3D;&#x3D;0时是登录成功</p><p><img src="https://blog-1258155859.cos.ap-guangzhou.myqcloud.com/image-20221203002017722.png" alt="image-20221203002017722"></p><p>把1改为0</p><p>也成功跳转了</p><p><img src="https://blog-1258155859.cos.ap-guangzhou.myqcloud.com/image-20221203002258843.png" alt="image-20221203002258843"></p><p>逻辑缺陷又有了</p><p>然后就是查资产</p><p>刚好5000w</p><p>案例也够</p><p><img src="https://blog-1258155859.cos.ap-guangzhou.myqcloud.com/image-20221203002637824.png" alt="image-20221203002637824"></p><p>这下可以水两个证书了</p><p><img src="https://blog-1258155859.cos.ap-guangzhou.myqcloud.com/aff42ce946f78d14de92b4ba8b3fcf5.jpg"></p><p>高高兴兴写完漏洞报告提交</p><p>等过几天一看</p><p>我裂开</p><p><img src="https://blog-1258155859.cos.ap-guangzhou.myqcloud.com/9eab38e137478fe2a12f0d36b116d9d.jpg"></p><p><img src="https://blog-1258155859.cos.ap-guangzhou.myqcloud.com/image-20221203002802987.png" alt="image-20221203002802987"></p><p><img src="https://blog-1258155859.cos.ap-guangzhou.myqcloud.com/image-20221203002851847.png" alt="image-20221203002851847"></p>]]></content>
      
      
      <categories>
          
          <category> web渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见的算法</title>
      <link href="/2022/10/13/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%AE%97%E6%B3%95/"/>
      <url>/2022/10/13/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="常见算法"><a href="#常见算法" class="headerlink" title="常见算法"></a>常见算法</h1><h2 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h2><h3 id="基本查找"><a href="#基本查找" class="headerlink" title="基本查找"></a>基本查找</h3><p>基本查找&#x2F;顺序查找</p><p>核心：从0索引开始挨个查找</p><p>需求：定义一个方法利用基本查找，查询某个元素是否存在</p><p>数据如下：{131,,127,147,81,103,23,7,79}</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">131</span>,<span class="number">127</span>,<span class="number">147</span>,<span class="number">81</span>,<span class="number">103</span>,<span class="number">23</span>,<span class="number">7</span>,<span class="number">79</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">81</span>;</span><br><span class="line">        System.out.println(basicSearch(arr,number));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//需要的参数</span></span><br><span class="line">    <span class="comment">//1.数组</span></span><br><span class="line">    <span class="comment">//2.要查找的元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">basicSearch</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> number)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] == number)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二分查找-x2F-折半查找"><a href="#二分查找-x2F-折半查找" class="headerlink" title="二分查找&#x2F;折半查找"></a>二分查找&#x2F;折半查找</h3><p>前提条件：数组中的数据必须是有序的</p><p>核心逻辑：每次排除一半的查找范围</p><p>1.min和max表示当前要查找的范围</p><p>2.mid是在min和max中间的</p><p>3.如果要查找的元素在mid的左边，缩小范围时，min不变，max等于mid减1</p><p>4.如果要查找的元素在mid的右边，缩小范围时，max不变，min等于mid加1</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> heima;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">7</span>,<span class="number">23</span>,<span class="number">79</span>,<span class="number">81</span>,<span class="number">103</span>,<span class="number">127</span>,<span class="number">131</span>,<span class="number">147</span>&#125;;</span><br><span class="line">        System.out.println(binarySeach(arr,<span class="number">81</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySeach</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> number)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//利用循环查找需要查找的数据</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (min &gt; max) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找到中间的位置</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (min + max) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//拿着mid的数据在数组中进行比较</span></span><br><span class="line">            <span class="keyword">if</span> (arr[mid] &gt; number) &#123;</span><br><span class="line">                <span class="comment">//大于</span></span><br><span class="line">                max = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; number) &#123;</span><br><span class="line">                <span class="comment">//小于</span></span><br><span class="line">                min = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二分查找改进（插值查找）"><a href="#二分查找改进（插值查找）" class="headerlink" title="二分查找改进（插值查找）"></a>二分查找改进（插值查找）</h4><p><img src="https://blog-1258155859.cos.ap-guangzhou.myqcloud.com/imgSnipaste_2022-08-19_19-56-52.png"></p><h3 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h3><p>分块原则1：前一块中的最大一块，小于后一块中所有的数据（块内无序，块间有序）</p><p>分块原则2：块的数量一般等于数字的个数开根号。比如：16个数字一般分为4块左右</p><p>核心思路：先确定要查找的元素在哪一块，然后在块内挨个查找</p><p><img src="https://blog-1258155859.cos.ap-guangzhou.myqcloud.com/imgSnipaste_2022-08-22_22-40-33.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> heima;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//分块查找</span></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">16</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">12</span>, <span class="number">21</span>,<span class="number">18</span>,</span><br><span class="line">                    <span class="number">32</span>,<span class="number">23</span>,<span class="number">37</span>,<span class="number">26</span>,<span class="number">45</span>,<span class="number">34</span>,</span><br><span class="line">                    <span class="number">50</span>,<span class="number">48</span>,<span class="number">61</span>,<span class="number">52</span>,<span class="number">73</span>,<span class="number">66</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建三个块的对象</span></span><br><span class="line">        <span class="type">Block</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Block</span>(<span class="number">21</span>,<span class="number">0</span>,<span class="number">5</span>);</span><br><span class="line">        <span class="type">Block</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Block</span>(<span class="number">45</span>,<span class="number">6</span>,<span class="number">11</span>);</span><br><span class="line">        <span class="type">Block</span> <span class="variable">b3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Block</span>(<span class="number">73</span>,<span class="number">12</span>,<span class="number">17</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义数组管理者三个对象（索引表）</span></span><br><span class="line">        Block[] blockArr = &#123;b1,b2,b3&#125;;</span><br><span class="line">        <span class="comment">//定义一个需要查找的数据</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">37</span>;</span><br><span class="line">        <span class="comment">//调用方法，传递索引表，数组，要查找的元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> getIndex(blockArr,arr,number);</span><br><span class="line">        <span class="comment">//打印</span></span><br><span class="line">        System.out.println(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getIndex</span><span class="params">(Block[] blockArr, <span class="type">int</span>[] arr, <span class="type">int</span> number)</span> &#123;</span><br><span class="line">        <span class="comment">//1.确定number在那一块</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">indexBlock</span> <span class="operator">=</span> findIndexBlock(blockArr,number);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(indexBlock == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取这一块的开始索引，结束索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">startIndex</span> <span class="operator">=</span> blockArr[indexBlock].getStartIndex();</span><br><span class="line">        <span class="type">int</span> <span class="variable">endIndex</span> <span class="operator">=</span> blockArr[indexBlock].getEndIndex();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex;i &lt;= endIndex;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] == number)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个方法用来确定number在哪个块中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findIndexBlock</span><span class="params">(Block[] blockArr,<span class="type">int</span> number)</span>&#123;</span><br><span class="line">        <span class="comment">//Block b1 = new Block(21,0,5);</span></span><br><span class="line">        <span class="comment">//Block b2 = new Block(45,6,11);</span></span><br><span class="line">        <span class="comment">//Block b3 = new Block(73,12,17);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//从0索引开始遍历blockArr，如果number小于max，那么就表示number就在这个表中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; blockArr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(number &lt;= blockArr[i].getMax())&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Block</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> max;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> startIndex;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> endIndex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Block</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Block</span><span class="params">(<span class="type">int</span> max, <span class="type">int</span> startIndex, <span class="type">int</span> endIndex)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.max = max;</span><br><span class="line">        <span class="built_in">this</span>.startIndex = startIndex;</span><br><span class="line">        <span class="built_in">this</span>.endIndex = endIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMax</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMax</span><span class="params">(<span class="type">int</span> max)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.max = max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getStartIndex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> startIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStartIndex</span><span class="params">(<span class="type">int</span> startIndex)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.startIndex = startIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getEndIndex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> endIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEndIndex</span><span class="params">(<span class="type">int</span> endIndex)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.endIndex = endIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>扩展的分块查找（无规律的数据）</p><p><img src="https://blog-1258155859.cos.ap-guangzhou.myqcloud.com/imgSnipaste_2022-08-22_23-11-35.png"></p><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序：相邻的数据两两比较，小的放前面，大的放后面</p><p>1.第一轮循环结束，最大值已经找到，在数组的最右边</p><p>2.第二轮循环只要在剩下的元素找最大值就可以了</p><p>3.如果数组中有n个数据，总共我们只要执行n-1轮代码就可以了</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> heima;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">D</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr.length- <span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j] &gt; arr[j + <span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.print(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>选择排序：从0索引开始，拿着每一个索引上的元素跟后面的元素依次比较，小的放前面，大的放后面，以此类推</p><p>1.从0索引开始，跟后面的元素一一比较</p><p>2.小的放前面，大的放后面</p><p>3.第一轮循环结束后，最小的数据已经确定</p><p>4.第二轮循环从1索引开始以此类推</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> heima;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i] &gt; arr[j])&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">                    arr[i] = arr[j];</span><br><span class="line">                    arr[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.print(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>插入排序：将0索引的元素到N索引的元素看做是有序的，把N+1索引的元素放到最后一个当成是无序的。遍历无序的数据，将遍历到的元素插入到有序序列中适当的位置，如遇到相同的数据，插在后面</p><p>N的</p><p>范围：0~最大索引</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> heima;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">F</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">3</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.找到无序的那一组是从哪个索引开始的</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">startIndex</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt; arr[i + <span class="number">1</span>])&#123;</span><br><span class="line">                startIndex = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.遍历从startIndex开始到最后一个元素，依次得到无序数据中的每一个元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">//记录当前要插入数据的索引</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; arr[j] &lt; arr[j - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">                arr[j - <span class="number">1</span>] = temp;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.print(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h3><p>递归指的是方法中调用方法本身的现象</p><p>递归方法的作用：把一个赋值的问题层层转化为一个与原问题相似的规模较小的问题来求解</p><p>书写递归的两个核心：</p><ul><li>找出口：什么时候不再调用方法</li><li>找规则：如何把大问题变成规模较小的问题</li></ul><p>递归求1~100之间的和</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> heima;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">G</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(getSum(<span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> number)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(number == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> number + getSum(number - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>递归求阶乘</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> heima;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">H</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(getFactorialRecursion(<span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getFactorialRecursion</span><span class="params">(<span class="type">int</span> number)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(number == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> number * getFactorialRecursion(number - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>第一轮：把0索引的数字作为基准数，确定基准数在数组中正确的位置。比基准数小的全部在左边，比基准数大的全部在右边</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> heima;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">I</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">6</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">8</span>&#125;;</span><br><span class="line"></span><br><span class="line">        quickSort(arr,<span class="number">0</span>,arr.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr.length;i++)&#123;</span><br><span class="line">            System.out.print(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//参数一：需要排序的数组</span></span><br><span class="line">    <span class="comment">//参数二、需要排序数组的起始索引</span></span><br><span class="line">    <span class="comment">//参数三、需要排序数组的结束索引</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="comment">//定义两个变量记录要查找的范围</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> j;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//递归的出口</span></span><br><span class="line">        <span class="keyword">if</span>(start &gt; end)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录基准数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">baseNumber</span> <span class="operator">=</span> arr[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//利用循环找到要交换的数字</span></span><br><span class="line">        <span class="keyword">while</span>(start != end)&#123;</span><br><span class="line">            <span class="comment">//利用end，从后往前找，找比基准数小的数字</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(end &lt;= start || arr[end] &lt; baseNumber)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                end--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//利用start，从前往后找，找比基准数大的数字</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(end &lt;= start || arr[start] &gt; baseNumber)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//把end和start指向的元素进行交换</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[start];</span><br><span class="line">            arr[start] = arr[end];</span><br><span class="line">            arr[end] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当start和end指向同一个元素的时候，那么上面的循环就会结束</span></span><br><span class="line">        <span class="comment">//表示已经找到了基准数在数组中应存入的位置</span></span><br><span class="line">        <span class="comment">//基准数归位</span></span><br><span class="line">        <span class="comment">//就是拿着这个范围中的第一个数字，跟start指向的元素进行交换</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[start];</span><br><span class="line">        arr[start] = temp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//确定6左边的范围，重复刚刚的事情</span></span><br><span class="line">        quickSort(arr,i,start - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//确定6右边的范围，重复刚刚的事情</span></span><br><span class="line">        quickSort(arr,start + <span class="number">1</span>,j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1.冒泡排序</p><ul><li>相邻的元素两两比较，小的放前面，大的放后面</li></ul><p>2.选择排序</p><ul><li>从0索引开始，拿着每一个索引上的元素跟后面的元素依次比较，小的放前面，大的放后面</li></ul><p>3.插入排序</p><ul><li>将数组分为有序和无序两组，遍历无序数据，将元素插入有序序列中即可</li></ul><p>4.快速排序</p><ul><li>将排序范围中的第一个数字作为基准数，再定义两个变量start和end</li><li>start从前往后找比基准数大的，end从后往前找比基准数小的</li><li>找到之后交换start和end指向的元素，并稀罕这一过程，直到start个end处于同一个位置，该位置是基准数应存入的位置，再让基准数归位</li><li>归位后的效果：基准数左边的，比基准数小，基准数右边的，比基准数大</li></ul><h1 id="综合练习"><a href="#综合练习" class="headerlink" title="综合练习"></a>综合练习</h1><h2 id="不死神兔"><a href="#不死神兔" class="headerlink" title="不死神兔"></a>不死神兔</h2><p>有一个很有名的数学逻辑题叫做不死神兔问题，有一对兔子，从出生后第三个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一队兔子，假如兔子都不死，问第十二个月的兔子对数为多少</p><p>特点：从第三个数据开始，是前两个数据的和（斐波那契数列）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> heima;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">one</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span> [<span class="number">12</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        arr[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = arr[i - <span class="number">1</span>] + arr[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(arr[<span class="number">11</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="猴吃桃子"><a href="#猴吃桃子" class="headerlink" title="猴吃桃子"></a>猴吃桃子</h2><p>有一堆桃子，第一只猴子吃了其中的一半，并多吃了一个，以后每天猴子都吃当前剩下来的一半，然后再多吃一个，第十天的时候（还没吃），发现只剩下一个桃子了，请问，最初总共多少个桃子</p><p>day10： 1</p><p>day9： （day10 + 1） *  2 &#x3D; 4</p><p>day8：（day9 + 1）* 2 &#x3D; 10</p><p>出口：day &#x3D;&#x3D; 10 剩下1</p><p>规律：每一天的桃子数量都是最后一天数量加1乘2</p><p>反向递归</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> heima;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">one</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(getCount(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">(<span class="type">int</span> day)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(day &lt;= <span class="number">0</span> || day &gt;= <span class="number">11</span>)&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;当前时间错误&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归出口</span></span><br><span class="line">        <span class="keyword">if</span>(day == <span class="number">10</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (getCount(day + <span class="number">1</span>) + <span class="number">1</span>) * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
