<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>漏洞平台介绍</title>
      <link href="/2022/11/30/%E6%BC%8F%E6%B4%9E%E5%B9%B3%E5%8F%B0%E4%BB%8B%E7%BB%8D/"/>
      <url>/2022/11/30/%E6%BC%8F%E6%B4%9E%E5%B9%B3%E5%8F%B0%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="漏洞平台介绍"><a href="#漏洞平台介绍" class="headerlink" title="漏洞平台介绍"></a>漏洞平台介绍</h2><h3 id="补天应急响应中心"><a href="#补天应急响应中心" class="headerlink" title="补天应急响应中心"></a>补天应急响应中心</h3><p>补天对网站权重要求是百度或移动权重大于等于1，谷歌大于等于3</p><p>交补天的漏洞如果通过审核的话，会根据你的漏洞危害程度分等级：严重、高危、中危、低危</p><p>然后根据漏洞等级和厂商的大小给相应的奖励</p><p>奖励分别有现金奖励跟kb币奖励，现金就不用多说了，kb的话可以在补天的商城换东西，1kb约等于5元</p><ul><li>反射XSS(公益不收，专属有些是收的)</li><li>CSRF</li><li>目录遍历</li><li>二进制</li><li>密码处的验证码爆破</li><li>http.sys远程代码执行漏洞</li><li>URL爆出了数据库</li><li>jquery version泄露</li><li>绝对路径泄露</li><li>Slow attack满攻击</li><li>短文件漏洞</li><li>DOS不收</li></ul><p><img src="https://blog-1258155859.cos.ap-guangzhou.myqcloud.com/20221130003837.png"></p><p><img src="https://blog-1258155859.cos.ap-guangzhou.myqcloud.com/image-20221130005700073.png"></p><h3 id="漏洞盒子"><a href="#漏洞盒子" class="headerlink" title="漏洞盒子"></a>漏洞盒子</h3><p>漏洞盒子的话对网站权重没有要求基本上是个漏洞都要</p><p>漏洞盒子公益SRC是没有奖励的</p><p>等级同上</p><p>PS：漏洞盒子审核嘎嘎慢</p><p><img src="https://blog-1258155859.cos.ap-guangzhou.myqcloud.com/20221130003921.png"></p><h3 id="CNVD"><a href="#CNVD" class="headerlink" title="CNVD"></a>CNVD</h3><p>CNVD全称为国家信息安全漏洞共享平台</p><p>交CNVD一般都是为了证书(至少我是，以后可以写简历上)</p><p>CNVD放发证书的条件</p><p>事件型漏洞需要是三大运营商（移动、联通、电信）的中高危漏洞，或者党政机关、重要行业单位、科研院所、重要企事业单位（如：中央国有大型企业、部委直属事业单位等）的高危事件型漏洞才会颁发原创漏洞证书</p><p>通用型漏洞的话厂商的注册资金需要达到5000W以上，旗下产品存在中高危漏洞，在互联网上不小于十例(最好的大于13例，提交页面写三例，然后漏洞报告里面写十例)</p><p><img src="https://blog-1258155859.cos.ap-guangzhou.myqcloud.com/20221130003946.png"></p><p>类似这样的漏洞平台还有很多，比如360安全响应中心，阿里应急响应中心等等，可以自行百度</p>]]></content>
      
      
      <categories>
          
          <category> web渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次没技术含量的sql注入(附带漏洞提交教程)</title>
      <link href="/2022/11/29/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%B2%A1%E6%8A%80%E6%9C%AF%E5%90%AB%E9%87%8F%E7%9A%84sql%E6%B3%A8%E5%85%A5-%E9%99%84%E5%B8%A6%E6%BC%8F%E6%B4%9E%E6%8F%90%E4%BA%A4%E6%95%99%E7%A8%8B/"/>
      <url>/2022/11/29/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%B2%A1%E6%8A%80%E6%9C%AF%E5%90%AB%E9%87%8F%E7%9A%84sql%E6%B3%A8%E5%85%A5-%E9%99%84%E5%B8%A6%E6%BC%8F%E6%B4%9E%E6%8F%90%E4%BA%A4%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="记一次没技术含量的SQL注入（附带漏洞提交教程）"><a href="#记一次没技术含量的SQL注入（附带漏洞提交教程）" class="headerlink" title="记一次没技术含量的SQL注入（附带漏洞提交教程）"></a>记一次没技术含量的SQL注入（附带漏洞提交教程）</h1><p>第一次写这种教程类的博客，写得不好的地方请见谅</p><p><img src="https://blog-1258155859.cos.ap-guangzhou.myqcloud.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20221129191844.jpg"></p><p>首先用谷歌语法挑选幸运儿</p><p><img src="https://blog-1258155859.cos.ap-guangzhou.myqcloud.com/20221130002603.png"></p><p>随便点进去一个站</p><p><img src="https://blog-1258155859.cos.ap-guangzhou.myqcloud.com/20221130002614.png"></p><p>复制域名到爱站那里瞧一下</p><p>谷歌PR3，可以交补天，就是它了</p><p><img src="https://blog-1258155859.cos.ap-guangzhou.myqcloud.com/20221130002723.png"></p><p>点进网站找存在id的地方</p><p>随手测一下</p><p><img src="https://blog-1258155859.cos.ap-guangzhou.myqcloud.com/20221130002754.png"></p><p>好家伙直接报错</p><p>稳稳的sql注入</p><p><img src="https://blog-1258155859.cos.ap-guangzhou.myqcloud.com/20221130002824.png"></p><p>没waf直接上心爱的Sqlmap</p><p>挖洞不规范，亲人两行泪</p><p>爆出库名就可以了</p><p>sqlmap命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap.py -u &quot;http://www.xxx.com&quot; --dbs --level 3 --batch</span><br></pre></td></tr></table></figure><p><img src="https://blog-1258155859.cos.ap-guangzhou.myqcloud.com/20221130002853.png"></p><p>接下来就是交到补天</p><p>sql注入一般都是中危及以上</p><p>下面是提交流程</p><p>以我博客域名为例</p><p><img src="https://blog-1258155859.cos.ap-guangzhou.myqcloud.com/20221130002940.png"></p><p><img src="https://blog-1258155859.cos.ap-guangzhou.myqcloud.com/20221130003027.png"></p>]]></content>
      
      
      <categories>
          
          <category> web渗透 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>命令行版学生管理系统</title>
      <link href="/2022/10/24/%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%89%88%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
      <url>/2022/10/24/%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%89%88%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="学生管理系统登录功能"><a href="#学生管理系统登录功能" class="headerlink" title="学生管理系统登录功能"></a>学生管理系统登录功能</h1><h2 id="需求："><a href="#需求：" class="headerlink" title="需求："></a>需求：</h2><p>​为学生管理系统书写一个登陆、注册、忘记密码的功能。</p><p>​只有用户登录成功之后，才能进入到学生管理系统中进行增删改查操作。</p><h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><h4 id="登录界面："><a href="#登录界面：" class="headerlink" title="登录界面："></a>登录界面：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;欢迎来到学生管理系统&quot;</span></span><br><span class="line"><span class="string">&quot;1:登录 2:注册 3:忘记密码 4:退出&quot;</span></span><br><span class="line"><span class="string">&quot;请输入您的选择:&quot;</span></span><br></pre></td></tr></table></figure><h4 id="用户类："><a href="#用户类：" class="headerlink" title="用户类："></a>用户类：</h4><p>​属性：用户名、密码、身份证号码、手机号码</p><h4 id="注册功能："><a href="#注册功能：" class="headerlink" title="注册功能："></a>注册功能：</h4><p>​1，用户名需要满足以下要求：</p><p>​验证要求：</p><p>​用户名唯一</p><p>​用户名长度必须在3~15位之间 </p><p>​只能是字母加数字的组合，但是不能是纯数字</p><p>​2，密码键盘输入两次，两次一致才可以进行注册。</p><p>​3，身份证号码需要验证。</p><p>​验证要求：</p><p>​长度为18位</p><p>​不能以0为开头</p><p>​前17位，必须都是数字</p><p>​最为一位可以是数字，也可以是大写X或小写x</p><p>​4，手机号验证。</p><p>​验证要求：</p><p>​长度为11位</p><p>​不能以0为开头</p><p>​必须都是数字</p><h4 id="登录功能："><a href="#登录功能：" class="headerlink" title="登录功能："></a>登录功能：</h4><p>​1，键盘录入用户名</p><p>​2，键盘录入密码</p><p>​3，键盘录入验证码</p><p>验证要求：</p><p>​用户名如果未注册，直接结束方法，并提示：用户名未注册，请先注册</p><p>​判断验证码是否正确，如不正确，重新输入</p><p>​再判断用户名和密码是否正确，有3次机会</p><h4 id="忘记密码："><a href="#忘记密码：" class="headerlink" title="忘记密码："></a>忘记密码：</h4><p>​       1，键盘录入用户名，判断当前用户名是否存在，如不存在，直接结束方法，并提示：未注册</p><p>​2，键盘录入身份证号码和手机号码</p><p>​3，判断当前用户的身份证号码和手机号码是否一致，</p><p>​如果一致，则提示输入密码，进行修改。</p><p>​如果不一致，则提示：账号信息不匹配，修改失败。</p><h4 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.Exit(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h4 id="验证码规则："><a href="#验证码规则：" class="headerlink" title="验证码规则："></a>验证码规则：</h4><p>​长度为5</p><p>​由4位大写或者小写字母和1位数字组成，同一个字母可重复</p><p>​数字可以出现在任意位置</p><p>比如：</p><p>​aQa1K</p><h1 id="学生管理系统增删改查功能"><a href="#学生管理系统增删改查功能" class="headerlink" title="学生管理系统增删改查功能"></a>学生管理系统增删改查功能</h1><h2 id="需求：-1"><a href="#需求：-1" class="headerlink" title="需求："></a>需求：</h2><p>​采取控制台的方式去书写学生管理系统。</p><h2 id="分析：-1"><a href="#分析：-1" class="headerlink" title="分析："></a>分析：</h2><h4 id="初始菜单："><a href="#初始菜单：" class="headerlink" title="初始菜单："></a>初始菜单：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;欢迎来到学生管理系统&quot;</span></span><br><span class="line"><span class="string">&quot;1：添加学生 2：删除学生 3：修改学生 4：查询学生 5：退出&quot;</span></span><br><span class="line"><span class="string">&quot;请输入您的选择:&quot;</span></span><br></pre></td></tr></table></figure><h4 id="学生类："><a href="#学生类：" class="headerlink" title="学生类："></a>学生类：</h4><p>​属性：id、姓名、年龄、家庭住址</p><h4 id="添加功能："><a href="#添加功能：" class="headerlink" title="添加功能："></a>添加功能：</h4><p>​键盘录入每一个学生信息并添加，需要满足以下要求：</p><ul><li>id唯一</li></ul><h4 id="删除功能："><a href="#删除功能：" class="headerlink" title="删除功能："></a>删除功能：</h4><p>​键盘录入要删除的学生id，需要满足以下要求：</p><ul><li>id存在删除</li><li>id不存在，需要提示不存在，并回到初始菜单</li></ul><h4 id="修改功能："><a href="#修改功能：" class="headerlink" title="修改功能："></a>修改功能：</h4><p>​键盘录入要修改的学生id，需要满足以下要求</p><ul><li>id存在，继续录入其他信息</li><li>id不存在，需要提示不存在，并回到初始菜单</li></ul><h4 id="查询功能："><a href="#查询功能：" class="headerlink" title="查询功能："></a>查询功能：</h4><p>​打印所有的学生信息，需要满足以下要求</p><ul><li>如果没有学生信息，提示：当前无学生信息，请添加后再查询</li><li>如果有学生信息，需要按照以下格式输出。（不用过于纠结对齐的问题）</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">id姓名年龄家庭住址</span><br><span class="line">heima001张三<span class="number">23</span> 南京</span><br><span class="line">heima002李四<span class="number">24</span> 北京</span><br><span class="line">heima003王五<span class="number">25</span> 广州</span><br><span class="line">heima004赵六 <span class="number">26</span> 深圳</span><br></pre></td></tr></table></figure><h4 id="退出-1"><a href="#退出-1" class="headerlink" title="退出"></a>退出</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.Exit(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="登录功能"><a href="#登录功能" class="headerlink" title="登录功能"></a>登录功能</h2><p>User</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String PhoneNumber;</span><br><span class="line">    <span class="keyword">private</span> String Personid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String username, String password, String phoneNumber, String personid)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">        PhoneNumber = phoneNumber;</span><br><span class="line">        Personid = personid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUsername</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPassword</span><span class="params">(String password)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPhoneNumber</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> PhoneNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPhoneNumber</span><span class="params">(String phoneNumber)</span> &#123;</span><br><span class="line">        PhoneNumber = phoneNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPersonid</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Personid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPersonid</span><span class="params">(String personid)</span> &#123;</span><br><span class="line">        Personid = personid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>App</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> jdk.swing.interop.SwingInterOpUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;User&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;欢迎来到学生管理系统&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;请选择操作：1、登录 2、注册 3、忘记密码 4、退出&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">input</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">            <span class="keyword">switch</span> (input) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    login(list);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    register(list);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                    forgetPassword(list);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;退出成功&quot;</span>);</span><br><span class="line">                    System.exit(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;没有这个选项&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用户注册功能</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(ArrayList&lt;User&gt; list)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">//用户名注册</span></span><br><span class="line">        String username;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入用户名&quot;</span>);</span><br><span class="line">            username = sc.next();</span><br><span class="line"></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> checkusername(username);</span><br><span class="line">            <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;用户名格式错误，请重新输入&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//校验用户名是否唯一</span></span><br><span class="line">            <span class="comment">//校验用户输入的username在集合中是否存在</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag2</span> <span class="operator">=</span> contains(list, username);</span><br><span class="line">            <span class="keyword">if</span> (flag2) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;用户名：&quot;</span> + username + <span class="string">&quot;已存在，请重新输入&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;用户名：&quot;</span> + username + <span class="string">&quot;可用&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//密码注册</span></span><br><span class="line">        String password;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入密码&quot;</span>);</span><br><span class="line">            password = sc.next();</span><br><span class="line">            System.out.println(<span class="string">&quot;请再次输入密码&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">aginpassword</span> <span class="operator">=</span> sc.next();</span><br><span class="line">            <span class="keyword">if</span> (!(password.equals(aginpassword))) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;密码不一致&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;密码一致&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//身份证号码</span></span><br><span class="line">        String personid;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入身份证号码&quot;</span>);</span><br><span class="line">            personid = sc.next();</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag3</span> <span class="operator">=</span> checkpersonid(personid);</span><br><span class="line">            <span class="keyword">if</span> (flag3) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;身份证号码满足条件&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;身份证号码格式错误，请重新输入&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//手机号码</span></span><br><span class="line">        String phoneNumber;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入手机号&quot;</span>);</span><br><span class="line">            phoneNumber = sc.next();</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag4</span> <span class="operator">=</span> checkphoneNumber(phoneNumber);</span><br><span class="line">            <span class="keyword">if</span> (flag4) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;手机号正确&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;手机号格式错误&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//用户名、密码、身份证、手机号添加到集合中</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(username, password, personid, phoneNumber);</span><br><span class="line">        list.add(u);</span><br><span class="line">        System.out.println(<span class="string">&quot;用户注册成功&quot;</span>);</span><br><span class="line"></span><br><span class="line">        printList(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用户登录功能</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(ArrayList&lt;User&gt; list)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入用户名：&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> sc.next();</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag1</span> <span class="operator">=</span> contains(list,username);</span><br><span class="line">            <span class="keyword">if</span>(!flag1)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;用户名&quot;</span> + username + <span class="string">&quot;未注册，请注册后再登录&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入密码：&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> sc.next();</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">rightCode</span> <span class="operator">=</span> getCode();</span><br><span class="line">                System.out.println(<span class="string">&quot;验证码为：&quot;</span>+rightCode);</span><br><span class="line">                System.out.println(<span class="string">&quot;请输入验证码：&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">Code</span> <span class="operator">=</span> sc.next();</span><br><span class="line">                <span class="keyword">if</span>(Code.equals(rightCode))&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;验证码正确&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;验证码错误&quot;</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//集中验证账号和密码是否正确</span></span><br><span class="line">            <span class="comment">//封装思想的利用</span></span><br><span class="line">            <span class="comment">//把一些零散的数据，封装成一个对象</span></span><br><span class="line">            <span class="type">User</span> <span class="variable">userInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(username,password,<span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> checkUsername(list,userInfo);</span><br><span class="line">            <span class="keyword">if</span>(result)&#123;</span><br><span class="line">                <span class="type">StudentSystem</span> <span class="variable">system</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StudentSystem</span>();</span><br><span class="line">                system.startStudentSystem();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;登录失败，账号或者密码错误，请重新输入&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//忘记密码功能</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">forgetPassword</span><span class="params">(ArrayList&lt;User&gt; list)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入用户名：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> sc.next();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> contains(list, username);</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前用户：&quot;</span> + username + <span class="string">&quot;未注册&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入身份证号码&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">personID</span> <span class="operator">=</span> sc.next();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入手机号码&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">phoneNumber</span> <span class="operator">=</span> sc.next();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//校验手机号身份证号码</span></span><br><span class="line">        <span class="comment">//跟用户名的是否一致</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> findIndex(list, username);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> list.get(index);</span><br><span class="line">        <span class="keyword">if</span> (!(user.getPassword().equalsIgnoreCase(personID) &amp;&amp; user.getPhoneNumber().equals(phoneNumber))) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;身份证号码或者电话号码输入错误&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String password;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入新的密码&quot;</span>);</span><br><span class="line">            password = sc.next();</span><br><span class="line">            System.out.println(<span class="string">&quot;请再次输入密码&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">againPassword</span> <span class="operator">=</span> sc.next();</span><br><span class="line">            <span class="keyword">if</span> (password.equals(againPassword)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;两次输入的密码一致&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;两次输入的密码不一致，请重新输入&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        user.setPassword(password);</span><br><span class="line">        System.out.println(<span class="string">&quot;密码修改成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//校验身份证电话号码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findIndex</span><span class="params">(ArrayList&lt;User&gt; list, String username)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">            <span class="keyword">if</span>(user.getUsername().equals(username))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printList</span><span class="params">(ArrayList&lt;User&gt; list)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">            System.out.println(<span class="string">&quot;用户名为：&quot;</span>+user.getUsername() + <span class="string">&quot;,&quot;</span> +<span class="string">&quot;密码为：：&quot;</span>+ user.getPassword() + <span class="string">&quot;,&quot;</span> + <span class="string">&quot;身份证号码为：&quot;</span>+ user.getPersonid() + <span class="string">&quot;,&quot;</span> +<span class="string">&quot;手机号码为：&quot;</span>+ user.getPhoneNumber());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//校验手机号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkphoneNumber</span><span class="params">(String phoneNumber)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(phoneNumber.length() != <span class="number">11</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(phoneNumber.startsWith(<span class="string">&quot;0&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; phoneNumber.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> phoneNumber.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(!(c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//校验身份证号码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkpersonid</span><span class="params">(String personID)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(personID.length() != <span class="number">18</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断首个字符是不是0，是的话返回true</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> personID.startsWith(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="comment">//如果0开头返回false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; personID.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> personID.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(!(c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后一位可用是数字也可以是大小写的X</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">endChar</span> <span class="operator">=</span> personID.charAt(personID.length() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(!(endChar &gt;= <span class="string">&#x27;0&#x27;</span>) &amp;&amp; (endChar &lt;= <span class="string">&#x27;9&#x27;</span>) || (endChar == <span class="string">&#x27;x&#x27;</span>) || (endChar == <span class="string">&#x27;X&#x27;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//校验用户名是否唯一</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(ArrayList&lt;User&gt; list, String username)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            <span class="comment">//获取集合中的每一个对象中的索引</span></span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">            <span class="type">String</span> <span class="variable">rightUsername</span> <span class="operator">=</span> user.getUsername();</span><br><span class="line">            <span class="keyword">if</span> (rightUsername.equals(username)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//验证用户名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkusername</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> username.length();</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">3</span> || len &gt; <span class="number">15</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; username.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> username.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (!((c &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;z&#x27;</span>) || (c &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;Z&#x27;</span>) || (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>))) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; username.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> username.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> ((c &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;z&#x27;</span>) || (c &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;Z&#x27;</span>)) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断用户输入的用户名密码跟集合中的用户名密码是否一致</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkUsername</span><span class="params">(ArrayList&lt;User&gt; list,User userInfo)</span> &#123;</span><br><span class="line">        <span class="comment">//遍历集合判断用户名密码是否存在</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; list.size();i++)&#123;</span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">            <span class="keyword">if</span>((user.getUsername().equals(userInfo.getUsername()) &amp;&amp; (user.getUsername().equals(userInfo.getUsername()))))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成一个验证码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">getCode</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//创建一个集合来添加所有的大小写字母</span></span><br><span class="line">        ArrayList&lt;Character&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//字符加数字会把字符变为对应的ASCII码然后再相加，前面在强转为字符</span></span><br><span class="line">            list.add((<span class="type">char</span>)(<span class="string">&#x27;a&#x27;</span> + i));</span><br><span class="line">            list.add((<span class="type">char</span>)(<span class="string">&#x27;A&#x27;</span> + i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//用于字符拼接成字符串</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> r.nextInt(list.size());</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> list.get(index);</span><br><span class="line">            <span class="comment">//把随机字符添加到sb当中</span></span><br><span class="line">            sb.append(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把一个随机数字添加到末尾</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> r.nextInt(<span class="number">10</span>);</span><br><span class="line">        sb.append(number);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//想要修改一个字符串</span></span><br><span class="line">        <span class="comment">//要想把字符要把字符串变成字符数组</span></span><br><span class="line">        <span class="type">char</span>[] arr = sb.toString().toCharArray();</span><br><span class="line">        <span class="comment">//拿着最后一个索引，跟随机索引指向的元素交换</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">randomIndex</span> <span class="operator">=</span> r.nextInt(arr.length);</span><br><span class="line">        <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> arr[randomIndex];</span><br><span class="line">        arr[randomIndex] = arr[arr.length - <span class="number">1</span>];</span><br><span class="line">        arr[arr.length - <span class="number">1</span>] = temp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(arr);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h2><p>Student</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String id, String name, <span class="type">int</span> age, String address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAddress</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAddress</span><span class="params">(String address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>StudentSystem</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.zip.Deflater;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentSystem</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">startStudentSystem</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        ArrayList&lt;Student&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;欢迎来到学生管理系统&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;1:添加学生 2:删除学生 3:修改学生 4:查询学生 5:退出&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入你的选择:&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">choose</span> <span class="operator">=</span> sc.next();</span><br><span class="line">            <span class="keyword">switch</span> (choose)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                    addStudent(list);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;2&quot;</span>:</span><br><span class="line">                    deletStudent(list);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;3&quot;</span>:</span><br><span class="line">                    updateStudent(list);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;4&quot;</span>:</span><br><span class="line">                    queryStudent(list);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;5&quot;</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;退出&quot;</span>);</span><br><span class="line">                    System.exit(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加学生</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addStudent</span><span class="params">(ArrayList&lt;Student&gt; list)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入学生ID:&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> sc.next();</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag1</span> <span class="operator">=</span> checkID(list,id);</span><br><span class="line">            <span class="keyword">if</span>(!flag1)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;当前ID已存在，请重新输入ID&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                student.setId(id);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;请输入学生姓名:&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> sc.next();</span><br><span class="line">            student.setName(name);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;请输入学生年龄:&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">ages</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">            student.setAge(ages);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;请输入学生家庭住址:&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">address</span> <span class="operator">=</span> sc.next();</span><br><span class="line">            student.setAddress(address);</span><br><span class="line"></span><br><span class="line">            list.add(student);</span><br><span class="line">            System.out.println(<span class="string">&quot;学生添加成功&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除约束</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">deletStudent</span><span class="params">(ArrayList&lt;Student&gt; list)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入需要删除的学生的id&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> sc.next();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag1</span> <span class="operator">=</span> checkID(list,id);</span><br><span class="line">        <span class="keyword">if</span>(flag1)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前学生不存在&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; list.size();i++)&#123;</span><br><span class="line">            <span class="type">Student</span> <span class="variable">username</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">            <span class="keyword">if</span>(id.equals(username.getId()))&#123;</span><br><span class="line">                list.remove(list.get(i));</span><br><span class="line">                System.out.println(<span class="string">&quot;学生信息删除成功&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">updateStudent</span><span class="params">(ArrayList&lt;Student&gt; list)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入需要修改的学生的id&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> sc.next();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag1</span> <span class="operator">=</span> checkID(list,id);</span><br><span class="line">        <span class="keyword">if</span>(flag1)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;需要修改的学生不存在&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; list.size();i++)&#123;</span><br><span class="line">            <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">            <span class="keyword">if</span>(id.equals(s.getId()))&#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;请输入修改后的学生id&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">ID</span> <span class="operator">=</span> sc.next();</span><br><span class="line">                s.setId(ID);</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;请输入修改后的学生姓名&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> sc.next();</span><br><span class="line">                s.setName(name);</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;请输入修改后的学生年龄&quot;</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">ages</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">                s.setAge(ages);</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;请输入修改后的家庭住址&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">address</span> <span class="operator">=</span> sc.next();</span><br><span class="line">                s.setAddress(address);</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;修改成功&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询学生</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">queryStudent</span><span class="params">(ArrayList&lt;Student&gt; list)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">if</span>(list.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前无学生信息，请添加后再查询&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;ID\t姓名\t年龄\t家庭住址\t&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; list.size();i++)&#123;</span><br><span class="line">            <span class="type">Student</span> <span class="variable">name</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">            System.out.println(name.getId() + <span class="string">&quot;\t&quot;</span> + name.getName() + <span class="string">&quot;\t&quot;</span> + name.getAge() + <span class="string">&quot;\t&quot;</span> + name.getAddress() + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//校验ID是否存在</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkID</span><span class="params">(ArrayList&lt;Student&gt; list, String inputID)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; list.size();i++)&#123;</span><br><span class="line">            <span class="comment">//获取集合中每一个对象的索引</span></span><br><span class="line">            <span class="type">Student</span> <span class="variable">nameID</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">            <span class="comment">//获取对象中的ID</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">ID</span> <span class="operator">=</span> nameID.getId();</span><br><span class="line">            <span class="comment">//判断集合中的ID跟用户输入的是否一致</span></span><br><span class="line">            <span class="keyword">if</span>((ID.equals(inputID)))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVASE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>漏洞笔记(四)</title>
      <link href="/2022/10/22/%E6%BC%8F%E6%B4%9E%E7%AC%94%E8%AE%B0(%E5%9B%9B)/"/>
      <url>/2022/10/22/%E6%BC%8F%E6%B4%9E%E7%AC%94%E8%AE%B0(%E5%9B%9B)/</url>
      
        <content type="html"><![CDATA[<h1 id="漏洞笔记-四"><a href="#漏洞笔记-四" class="headerlink" title="漏洞笔记(四)"></a>漏洞笔记(四)</h1><h2 id="外部实体引用payload"><a href="#外部实体引用payload" class="headerlink" title="外部实体引用payload"></a>外部实体引用payload</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml&gt; version = <span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">ANY</span> [</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY f <span class="keyword">SYSTEM</span> <span class="string">&quot;file:///ect/passwd&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">x</span>&gt;</span><span class="symbol">&amp;f;</span><span class="tag">&lt;/<span class="name">x</span>&gt;</span></span><br></pre></td></tr></table></figure><p>外部实体引用可以支持http、file、ftp等协议</p><p>如果一个接口支持接收xml数据，且没有对xml数据做任何安全上的措施，就可能导致xxe漏洞</p><h3 id="PHP-simptexml-load-string-函数"><a href="#PHP-simptexml-load-string-函数" class="headerlink" title="PHP simptexml_load_string()函数"></a>PHP simptexml_load_string()函数</h3><p>函数转换形式良好的XML字符串为SimpleXMLElement对象</p><p>在PHP里面解析XML用的是libxml，其中在&gt;&#x3D; 2.9.0的版本中，默认的是禁止解析xml外部实体内容的</p><p>XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致攻击者可以构造一个恶意的XML</p><h2 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h2><p><strong>SSRF(Server-Side Request Forgery:服务器端请求伪造)</strong></p><p>其形成的原因大都是由于服务端<strong>提供了从其他服务器应用获取数据的功能</strong>,但又没有对目标地址做严格过滤与限制</p><p>导致攻击者可以传入任意的地址来让后端服务器对其发起请求,并返回对该目标地址请求的数据</p><p>数据流:攻击者—–&gt;服务器—-&gt;目标地址</p><p>根据后台使用的函数的不同,对应的影响和利用方法又有不一样            </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PHP中下面函数的使用不当会导致SSRF:</span><br><span class="line">file_get_contents()</span><br><span class="line">fsockopen()</span><br><span class="line">curl_exec()</span><br><span class="line">           </span><br></pre></td></tr></table></figure><p>如果一定要通过后台服务器远程去对用户指定(“或者预埋在前端的请求”)的地址进行资源请求,<strong>则请做好目标地址的过滤</strong>。</p><h2 id="Weblogic漏洞"><a href="#Weblogic漏洞" class="headerlink" title="Weblogic漏洞"></a>Weblogic漏洞</h2><h3 id="Weblogic相关介绍"><a href="#Weblogic相关介绍" class="headerlink" title="Weblogic相关介绍"></a>Weblogic相关介绍</h3><p>基于JAVAEE架构的中间件，WebLogic是用于开发集成部署和管理的大型分布式Web应用</p><h3 id="Weblogic特征"><a href="#Weblogic特征" class="headerlink" title="Weblogic特征"></a>Weblogic特征</h3><ul><li>端口默认：7001</li><li>Web界面：Error 404–Not Found</li></ul><h3 id="Weblogic漏洞利用"><a href="#Weblogic漏洞利用" class="headerlink" title="Weblogic漏洞利用"></a>Weblogic漏洞利用</h3><h4 id="获取资产"><a href="#获取资产" class="headerlink" title="获取资产"></a>获取资产</h4><p>shodan fofa 钟馗之眼等</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">app=&quot;BEA-Weblogic-Server&quot;</span><br></pre></td></tr></table></figure><p>google hacking</p><p>inurl:漏洞地址</p><p>intitle：weblogic等</p><p>批量扫描脚本：WeblogicScan，github下载</p><h2 id="常见的中间件漏洞"><a href="#常见的中间件漏洞" class="headerlink" title="常见的中间件漏洞"></a>常见的中间件漏洞</h2><h3 id="IIS中间件漏洞"><a href="#IIS中间件漏洞" class="headerlink" title="IIS中间件漏洞"></a>IIS中间件漏洞</h3><h4 id="HTTPS-sys远程代码执行漏洞"><a href="#HTTPS-sys远程代码执行漏洞" class="headerlink" title="HTTPS.sys远程代码执行漏洞"></a>HTTPS.sys远程代码执行漏洞</h4><p>Http.sys是Microsoft Windows处理HTTP请求的内核驱动程序。HTTP.sys会错误解析某些特殊构造的HTTP请求，导致远程代码执行漏洞。成功利用此漏洞后，攻击者可在System帐户上下文中执行任意代码。由于此漏洞存在于内核驱动程序中，攻击者也可以远程导致操作系统蓝屏。此次受影响的系统中，Windows7、Windows8、WindowsServer 2008 R2和WindowsServer 2012所带的HTTP.sys驱动均存在一个远程代码执行漏洞，远程攻击者可以通过IIS7(或更高版本)服务将恶意的HTTP请求传递给HTTP.sys驱动，通过发送恶意的HTTP请求导致远程代码执行或操作系统蓝屏。</p><p>测试：</p><ul><li>通过服务器返回信息的特征</li><li>使用Metasploit漏洞利用</li></ul><h3 id="apachu"><a href="#apachu" class="headerlink" title="apachu"></a>apachu</h3><p>apache目录结构</p><ul><li>bin：存放常用命令工具，如httpd</li><li>cgi-bin：存放linux下常用命令，如xxx.sh</li><li>error：错误记录</li><li>htdocs：网站源码</li><li>icons：网站图标</li><li>manual：手册</li><li>modules：扩展模块</li></ul><h4 id="未知拓展名解析漏洞"><a href="#未知拓展名解析漏洞" class="headerlink" title="未知拓展名解析漏洞"></a>未知拓展名解析漏洞</h4><h5 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h5><p>Apache默认一个文件可以有多个以点分割的后缀，当最右边的后缀无法识别，则继续向左识别，直到识别到合法后缀才进行解析。那么哪些后缀Apache不认识？不在mime.types 里面的都不认识 （Multipurpose Internet Mail Extensions）</p><p>1、使用module模式与php结合的所有版本apache存在未知扩展名解析漏洞。</p><p>2、使用fastcgi模式与php结合的所有版本apache不存在此漏洞。</p><p>3、利用此漏洞时必须保证扩展名中至少带有一个.php，不然将默认作为txt&#x2F;html文档处理。</p>]]></content>
      
      
      <categories>
          
          <category> web渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>漏洞笔记(三)</title>
      <link href="/2022/10/22/%E6%BC%8F%E6%B4%9E%E7%AC%94%E8%AE%B0(%E4%B8%89)/"/>
      <url>/2022/10/22/%E6%BC%8F%E6%B4%9E%E7%AC%94%E8%AE%B0(%E4%B8%89)/</url>
      
        <content type="html"><![CDATA[<h1 id="漏洞笔记-三"><a href="#漏洞笔记-三" class="headerlink" title="漏洞笔记(三)"></a>漏洞笔记(三)</h1><h2 id="越权漏洞"><a href="#越权漏洞" class="headerlink" title="越权漏洞"></a>越权漏洞</h2><h3 id="越权漏洞概述"><a href="#越权漏洞概述" class="headerlink" title="越权漏洞概述"></a>越权漏洞概述</h3><p>信息安全行业关于权限有两个常见的概念，一个叫越权，一个叫提权。提权指的是低权限的用户通过技术手段提升到高权限的用户。（权限一般是指计算机权限，提权是指从用户权限提升到管理员权限）。越权一般是指低权限用户进行高权限的操作或平级操作，越权漏洞出现的地方一般以网页、app为主。</p><p>越权漏洞是一种很常见的逻辑安全漏洞。是由于服务器端对客户提出的数据操作请求过分信任，忽略了对该用户操作权限的判定，导致修改相关参数就可以拥有了其他账户的增、删、查、改功能，从而导致越权漏洞。</p><p>像越权漏洞这种逻辑安全漏洞是参加工作以后我们的制胜法宝。<br>像SQL注入、XSS、CSRF、文件上传这类漏洞用企业级工具(比如awvs、绿盟科技公司的极光软件)可以测出来，但是逻辑安全漏洞则需要手动才能测出来，因为代码本身没问题，而是程序设计思路有问题。</p><h3 id="常见越权的方式"><a href="#常见越权的方式" class="headerlink" title="常见越权的方式"></a>常见越权的方式</h3><ul><li>1.通过修改GET传参来越权</li><li>2.修改POST传参进行越权</li><li>3.修改cookie传参进行越权<br>注意：但凡看到可能代表身份或者某些信息的传参，都可以去尝试修改看看有没有漏洞。</li></ul><h3 id="测试流程"><a href="#测试流程" class="headerlink" title="测试流程"></a>测试流程</h3><p>登录A用户时，正常更改或者是查看A用户信息，然后抓取数据包，将传参ID修改为其他用户，如果成功查看或者修改了同权限其他用户的信息就属于水平越权测试。（如果可以影响到高权限用户就是垂直越权）</p><p>测试过程中的传参ID参数需要自己检测（常见：uid&#x3D; id&#x3D; user&#x3D; 等）通常使用burp进行爆破传参（传参可能在GET、POST、COOKIE传参）</p><h3 id="常见越权漏洞——平行越权"><a href="#常见越权漏洞——平行越权" class="headerlink" title="常见越权漏洞——平行越权"></a>常见越权漏洞——平行越权</h3><p>A用户和B用户属于同一级别用户，蛋各自不能操作对方个人信息，A用户如果越权操作B用户的个人信息的情况被称为平行越权</p><h3 id="常见越权漏洞——垂直越权"><a href="#常见越权漏洞——垂直越权" class="headerlink" title="常见越权漏洞——垂直越权"></a>常见越权漏洞——垂直越权</h3><p>A用户权限高于B用户，B用户越权操作A用户的权限的情况被称为垂直越权</p><h2 id="PHP序列化"><a href="#PHP序列化" class="headerlink" title="PHP序列化"></a>PHP序列化</h2><h3 id="什么是序列化"><a href="#什么是序列化" class="headerlink" title="什么是序列化"></a>什么是序列化</h3><p>PHP通过serialize()函数将对象转换为可传输的字符串，这里的字符串可以放在session缓存、cookie等地方，作为用户登录或操作的凭证。序列化一个对象将会保存对象的所有变量，但是不会保存对象的方法，只会保存类的名字</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Syclover</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="variable">$Vanzy</span> = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="variable">$Myth3em</span> = <span class="string">&#x27;handsome boy&#x27;</span>;</span><br><span class="line">        <span class="keyword">protected</span> <span class="variable">$zzy</span> = <span class="string">&#x27;handsome too&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable">$a</span> = <span class="keyword">new</span> <span class="title class_">Syclover</span>();</span><br><span class="line">    <span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://blog-1258155859.cos.ap-guangzhou.myqcloud.com/imgimgimage-20220925170805963.png" alt="image-20220925170805963"></p><h3 id="什么是反序列化"><a href="#什么是反序列化" class="headerlink" title="什么是反序列化"></a>什么是反序列化</h3><p>反序列化就是通过unserialize()函数的字节流还原成对象，一般会放在服务端，对客户传入的序列化字符串进行解析</p><h3 id="反序列化漏洞成因"><a href="#反序列化漏洞成因" class="headerlink" title="反序列化漏洞成因"></a>反序列化漏洞成因</h3><p>当服务端存在能够进行反序列化操作的函数，且函数的参数是可控时，就可能造成反序列化漏洞，如果服务端存在一些可以触发的magic methods，且存在命令执行或文件包含&#x2F;写文件的函数，那么我们可以通过构造popchain来触发，达到Getshell或File Include的目的</p><h3 id="常见的PHP-magic-methods"><a href="#常见的PHP-magic-methods" class="headerlink" title="常见的PHP magic methods"></a>常见的PHP magic methods</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__construct()，类的构造函数,当对象被创建时调用</span><br><span class="line">__destruct()，类的析构函数，当对象被销毁时调用</span><br><span class="line">__call()，在对象中调用一个不可访问方法时调用</span><br><span class="line">__callStatic()，用静态方式中调用一个不可访问方法时调用</span><br><span class="line">__get()，从不可访问的属性读取数据时调用</span><br><span class="line">__set()，设置一个类的成员变量时调用</span><br><span class="line">__isset()，当对不可访问属性调用isset()或empty()时调用</span><br><span class="line">__unset()，当对不可访问属性调用unset()时被调用。</span><br><span class="line">__sleep()，执行serialize()前时，先会调用这个函数</span><br><span class="line">__wakeup()，执行unserialize()前时，先会调用这个函数</span><br><span class="line">__toString()，类被当成字符串时使用时被调用（echo file_exists）</span><br><span class="line">__invoke()，调用函数的方式调用一个对象时的回应方法</span><br><span class="line">__set_state()，调用var_export()导出类时，此静态方法会被调用。</span><br><span class="line">__clone()，当对象复制完成时调用</span><br><span class="line">__autoload()，尝试加载未定义的类</span><br><span class="line">__debugInfo()，打印所需调试信息</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="XXE漏洞"><a href="#XXE漏洞" class="headerlink" title="XXE漏洞"></a>XXE漏洞</h2><h3 id="漏洞原因"><a href="#漏洞原因" class="headerlink" title="漏洞原因"></a>漏洞原因</h3><p>XML被设计为传输和存储数据，XML文档结构包括XML声明、DTD文档类型定义(可选)、文档元素，其焦点是数据的内容，其把数据从HTML分离，是独立于软件和硬件的信息传输工具。XXE漏洞全称XMLExternal Entity Injection，即xml外部实体注入漏洞，XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件，造成文件读取、命令执行、内网端口扫描、攻击内网网站等危害。</p><h3 id="XML文档结构"><a href="#XML文档结构" class="headerlink" title="XML文档结构"></a>XML文档结构</h3><ul><li>XML文档必须有一个元素</li><li>XML元素必须有一个关闭标签</li><li>XML标签对大小写敏感</li><li>XML元素必须被正确的嵌套</li><li>XML属性值必须加引号</li></ul><h3 id="DTD"><a href="#DTD" class="headerlink" title="DTD"></a>DTD</h3><p>XML文档结构包含XML声明、DTD文档类型定义、文档元素。而DTD就是用来控制文档的一个格式规范的。下面中的DTD就定义了XML的根元素为note，然后根元素下面有一些子元素（to、from、heading、body），那么下面的文档元素就必须是这些元素</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span>//这一行是 XML 文档定义</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">note</span> [</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="keyword">note</span> (<span class="keyword">to</span>,<span class="keyword">from</span>,<span class="keyword">heading</span>,<span class="keyword">body</span>)&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="keyword">to</span> (<span class="keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="keyword">from</span> (<span class="keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="keyword">heading</span> (<span class="keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="keyword">body</span> (<span class="keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line">//以上是文档类型</span><br><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">to</span>&gt;</span>George<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">from</span>&gt;</span>John<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">heading</span>&gt;</span>Reminder<span class="tag">&lt;/<span class="name">heading</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span>Dont forget the meeting<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br><span class="line">//以上是文档元素</span><br></pre></td></tr></table></figure><p>DTD：Document type Definition即文档类型定义，用来为XML文档定义语义约束</p><p>1、DTD内部声明</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE 根元素 [元素声明]&gt;</span><br></pre></td></tr></table></figure><p>2、DTD外部引用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE 根元素 SYSTEM &quot;外部DTD的URL&quot;&gt;</span><br></pre></td></tr></table></figure><p>3、引用公共DTD</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE 根元素名称 PUBUC &quot;DTD标识名&quot; &quot;公共DTD的URL&quot;&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>漏洞笔记(二)</title>
      <link href="/2022/10/22/%E6%BC%8F%E6%B4%9E%E7%AC%94%E8%AE%B0(%E4%BA%8C)/"/>
      <url>/2022/10/22/%E6%BC%8F%E6%B4%9E%E7%AC%94%E8%AE%B0(%E4%BA%8C)/</url>
      
        <content type="html"><![CDATA[<h1 id="漏洞笔记-二"><a href="#漏洞笔记-二" class="headerlink" title="漏洞笔记(二)"></a>漏洞笔记(二)</h1><h2 id="远程命令、代码执行漏洞"><a href="#远程命令、代码执行漏洞" class="headerlink" title="远程命令、代码执行漏洞"></a>远程命令、代码执行漏洞</h2><p>RCE漏洞，可以让攻击者直接向后台服务器远程注入操作系统命令或者代码，从而控制后台系统。                    </p><h3 id="远程系统命令执行"><a href="#远程系统命令执行" class="headerlink" title="远程系统命令执行"></a>远程系统命令执行</h3><p>一般出现这种漏洞，是因为应用系统从设计上需要给用户提供指定的远程命令操作的接口<br>比如我们常见的路由器、防火墙、入侵检测等设备的web管理界面上<br>一般会给用户提供一个ping操作的web界面，用户从web界面输入目标IP，提交后，后台会对该IP地址进行一次ping测试，并返回测试结果。</p><p>而，如果，设计者在完成该功能时，没有做严格的安全控制，则可能会导致攻击者通过该接口提交“意想不到”的命令，从而让后台进行执行，从而控制整个后台服务器，现在很多的甲方企业都开始实施自动化运维,大量的系统操作会通过”自动化运维平台”进行操作。</p><p>在这种平台上往往会出现远程系统命令执行的漏洞,不信的话现在就可以找你们运维部的系统测试一下,会有意想不到的”收获”-_- </p><h3 id="远程代码执行"><a href="#远程代码执行" class="headerlink" title="远程代码执行"></a>远程代码执行</h3><p>同样的道理,因为需求设计,后台有时候也会把用户的输入作为代码的一部分进行执行,也就造成了远程代码执行漏洞。不管是使用了代码执行的函数,还是使用了不安全的反序列化等等。                    </p><p>因此，如果需要给前端用户提供操作类的API接口，一定需要对接口输入的内容进行严格的判断，比如实施严格的白名单策略会是一个比较好的方法。                                        </p><h2 id="文件包含漏洞"><a href="#文件包含漏洞" class="headerlink" title="文件包含漏洞"></a>文件包含漏洞</h2><p>1：随着网站的业务的需求，程序开发人员一般希望代码更加灵活，所以将被包含的文件设置为变量，用来进行动态调用，但是正是这种灵活性通过动态变量的方式引入需要包含的文件时，用户对这个变量可控而且服务端又没有做合理的校检或者校检被绕过就造成了文件包含漏洞。</p><p>经常见到的函数</p><p>1：include（）当前使用该函数包含文件时，只有代码执行到include（）函数时将文件包含起来，发生错误时给出一个警告，然后继续执行语句</p><p>2，include_once()功能和include（）相同，区别当重复调用一个文件时，程序只调用一次</p><p>3：reguire（）执行如果发生错误，函数会输出错误信息，并终止脚本的运行</p><p>4：require_once（）功能与require（）相同区别在于当重复调用一个文件时，程序只调用一次</p><p>5：nighcight_file(),show_source()函数对文件进行语法高亮显示，通常能看到源代码</p><p>6：readfile（），file_get_contents（）函数读取一个文件，并写入输出缓冲</p><p>7：fopen（），打开一个文件或者url</p><p>几乎所有的脚本语言中都提供文件包含的功能，但文件包含漏洞在php中居多，而在jsp\ASP\ASP.NETC 程序中非常少，甚至没有文件包含漏洞的存在。</p><h3 id="本地文件包含漏洞"><a href="#本地文件包含漏洞" class="headerlink" title="本地文件包含漏洞"></a>本地文件包含漏洞</h3><p>当被包含的文件在服务器本地时，就形成的本地文件包含漏洞</p><h3 id="远程文件包含漏洞"><a href="#远程文件包含漏洞" class="headerlink" title="远程文件包含漏洞"></a>远程文件包含漏洞</h3><p>本地文件包含和远程文件包含造成漏洞的原因是一样的，当php.ini 中的配置选项allow_url_fopen和allow_url_include为ON的话，则包含的文件可以是第三方服务器中的文件，这样就形成了远程文件包含漏洞。 </p><h3 id="文件包含漏洞之上传漏洞的利用"><a href="#文件包含漏洞之上传漏洞的利用" class="headerlink" title="文件包含漏洞之上传漏洞的利用"></a>文件包含漏洞之上传漏洞的利用</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>制作一个图片木马，通过文件上传漏洞上传</li><li>通过文件包含漏洞对该木马进行“包含”</li><li>获取执行结果</li></ul><h3 id="不安全的文件下载和上传（任意文件下载）"><a href="#不安全的文件下载和上传（任意文件下载）" class="headerlink" title="不安全的文件下载和上传（任意文件下载）"></a>不安全的文件下载和上传（任意文件下载）</h3><p>很多网站都会提供文件下载功能，即用户可以通过点击下载链接，下载到链接所对应的文件</p><p>但是，如果文件下载功能设计不当，则可能导致攻击者可以通过构造文件路径，从而获取到后台服务器上的其他的敏感文件（又称：任意文件下载）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">../../../../ect/password</span><br></pre></td></tr></table></figure><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><p>因为业务功能需要，很多web站点都有文件上传的接口，比如：</p><p>1.注册时上传头像图片（比如jpg,png,gif等）</p><p>2.上传文件附件（doc，xls等）</p><p>而在后台开发时并没有对上传的文件功能进行安全考虑或者采用了有缺陷的措施，导致攻击者可以通过一些手段绕过安全措施从而上传一些恶意文件（如：一句话木马）</p><p>从而通过对该恶意文件的访问来控制整个web后台</p><h3 id="测试流程"><a href="#测试流程" class="headerlink" title="测试流程"></a>测试流程</h3><p>1、搜集可上传文件接口</p><p>需要手动在网站页面查找可以上传文件的接口，比如头像上传，附件上传，图片上传，模板上传等位置，并做好记录（重点检查位置：用户中心，会员中心，后台管理等）。</p><p>2、上传常规文件并进行抓包，分析可能存在的漏洞</p><p>通过上传符合要求的文件，抓取数据包，对数据包传输与返回的数据进行分析，手工修改传输包中的一些参数和数据，通过测试了解文件上传机制和检测项。</p><p>3、绕过检测机制，上传webshell文件</p><p>根据之前的测试，通过各种绕过技术将webshell文件上传到服务器中，并可以正常执行。这里需要注意的是，我们要了解服务器可以执行那类文件，一般可分为asp、PHP、jsp、aspx，asa等类型。</p><p>仅仅上传了jpg、txt等非可执行文件，是没办法直接利用的，可以配合文件包含进行利用</p><h4 id="前端绕过"><a href="#前端绕过" class="headerlink" title="前端绕过"></a>前端绕过</h4><p>删除：onchange&#x3D;”checkFileExt(this.value)”</p><h3 id="服务端绕过"><a href="#服务端绕过" class="headerlink" title="服务端绕过"></a>服务端绕过</h3><h4 id="MIME绕过"><a href="#MIME绕过" class="headerlink" title="MIME绕过"></a>MIME绕过</h4><p>MIME多用途互联网邮件扩展类型，是设定某种扩展名的文件用一种应用程序来打开的方式类型，该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开，多用于指定一些客户端自定义文件名，以及一些媒体文件打开方式</p><p>每个MIME类型由两部分组成，前面是数据的大类型，例如：声音audio、图像image等，后面定义具体的种类。常见的MIME类型。</p><p>比如：</p><p>超文本标记语言：.html、text、html</p><p>普通文本：text、TXT、plain</p><p>PRT文本：rtf、appliction、</p><p>GIF图像：gif</p><p>JPEG图形：ipeg、jpg</p><p>抓包修改识别出来的文件名</p><h4 id="getimagesize-类型验证"><a href="#getimagesize-类型验证" class="headerlink" title="getimagesize()类型验证"></a>getimagesize()类型验证</h4><p>getimagesize()返回结果中有文件大小和文件类型，如果这个来获取类型，从而判断是否有图片的话，会存在问题</p><p>是否可以绕过呢？可以，因为图片头可以被伪渣</p><p>图片木马的制作：</p><p>方法1：直接伪渣头部GIF89A</p><p>CMD：copy &#x2F;b test.png + muma.php ccc.png</p><p>方法2：使用GIMP（开源图片修改软件），通过增加备注，写入执行命令</p>]]></content>
      
      
      <categories>
          
          <category> web渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>漏洞笔记(一)</title>
      <link href="/2022/10/22/%E6%BC%8F%E6%B4%9E%E7%AC%94%E8%AE%B0(%E4%B8%80)/"/>
      <url>/2022/10/22/%E6%BC%8F%E6%B4%9E%E7%AC%94%E8%AE%B0(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<h1 id="漏洞笔记-一"><a href="#漏洞笔记-一" class="headerlink" title="漏洞笔记(一)"></a>漏洞笔记(一)</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="什么是信息收集"><a href="#什么是信息收集" class="headerlink" title="什么是信息收集"></a>什么是信息收集</h3><p>信息收集是值通过各种方式获取所需要的信息，以便我们在后续的渗透过程中更好的进行，比如目标站点IP、中间件、脚本语言、端口、邮箱等等，信息收集包含资产收集但不限于资产收集</p><h3 id="信息收集的意义"><a href="#信息收集的意义" class="headerlink" title="信息收集的意义"></a>信息收集的意义</h3><ul><li><p>信息收集是渗透测试成功的保障</p></li><li><p>更多的暴露面</p></li><li><p>更大的可能性</p></li></ul><h3 id="信息收集的分类"><a href="#信息收集的分类" class="headerlink" title="信息收集的分类"></a>信息收集的分类</h3><ul><li>主动信息收集<ul><li>通过直接访问网站在网站进行操作、对网站进行扫描等，这种是有网络流经过目标服务器的信息收集方式</li></ul></li><li>被动信息收集<ul><li>基于公开的渠道，比如搜索引擎等，在不与目标直接交互的情况下获取信息，并且尽量避免留下痕迹</li></ul></li></ul><h3 id="收集那些信息"><a href="#收集那些信息" class="headerlink" title="收集那些信息"></a>收集那些信息</h3><ul><li>服务器信息：端口、服务、真实IP</li><li>网站信息：网站架构（操作系统、中间件、数据库、编程语言）、指纹信息、WAF、敏感目录、敏感文件、源码泄露、旁站查询、C段查询</li><li>域名信息：whois、备案信息、子域名</li><li>人员信息：姓名、职务、生日、联络方式、邮件地址</li></ul><h3 id="子域名信息收集"><a href="#子域名信息收集" class="headerlink" title="子域名信息收集"></a>子域名信息收集</h3><h4 id="子域名介绍"><a href="#子域名介绍" class="headerlink" title="子域名介绍"></a>子域名介绍</h4><p>子域名指二级域名，二级域名是顶级域名（一级域名）的下一级</p><p>比如mail.heetian.com和bbs.beetian.com是heetian.com的 子域，而heetian.com则是顶级域名.com的子域名</p><h3 id="网站指纹识别"><a href="#网站指纹识别" class="headerlink" title="网站指纹识别"></a>网站指纹识别</h3><h4 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h4><ul><li>ping判断：windows的TTL值一般为128，Linux则为64.TTL大于100的一般为windowns，几十的一般为Linux</li><li>nmap -O 参数</li><li>windows大小写不敏感，Linux则区分大小写</li></ul><h4 id="CMS识别"><a href="#CMS识别" class="headerlink" title="CMS识别"></a>CMS识别</h4><p>常见CMS：dedecms（织梦）、Discuz、phpcms等</p><ul><li>在线识别工具：<a href="http://whatweb.bugscaner.com/">http://whatweb.bugscaner.com/</a></li></ul><h3 id="敏感文件及目录探测"><a href="#敏感文件及目录探测" class="headerlink" title="敏感文件及目录探测"></a>敏感文件及目录探测</h3><h4 id="敏感文件、目录"><a href="#敏感文件、目录" class="headerlink" title="敏感文件、目录"></a>敏感文件、目录</h4><p>github、git、SVN、.DS_Store、.hg、.bzr、cvs、WEB-INF、备份文件</p><ul><li>github泄露：开发人员将代码上传到网站。在上传的时候，没有删除重要的一些信息。如邮箱信息，svn信息，内部账号等，数据库连接信息，服务器配置信息等</li></ul><h4 id="网站waf识别"><a href="#网站waf识别" class="headerlink" title="网站waf识别"></a>网站waf识别</h4><p>waf00f：github下载</p><p>nmap -p 80,443 –script http-waf-detect ip</p><p>nmap -p 80,443 –script http-waf-fingerprint ip</p><h2 id="暴力破解漏洞解析"><a href="#暴力破解漏洞解析" class="headerlink" title="暴力破解漏洞解析"></a>暴力破解漏洞解析</h2><h3 id="暴力破解漏洞概述"><a href="#暴力破解漏洞概述" class="headerlink" title="暴力破解漏洞概述"></a>暴力破解漏洞概述</h3><p>如果一个网站没有对登录接口实施防暴力破解的措施，或实施了不合理的措施。则称该网站存在暴力破解漏洞</p><ul><li>是否要求用户设置了复杂的密码</li><li>是否每次认证都使用安全的验证码</li><li>是否尝试登录的行为进行判断和限制</li><li>是否在必要的情况下采用了双因素认证</li></ul><h3 id="暴力破解漏洞测试流程"><a href="#暴力破解漏洞测试流程" class="headerlink" title="暴力破解漏洞测试流程"></a>暴力破解漏洞测试流程</h3><p>确认登录接口的脆弱性</p><p>确认目标是否存在暴力破解的漏洞</p><p>比如：尝试登录——抓包——观察验证元素和response信息，判断是否存在被暴力破解的可能</p><p>技巧：</p><p>如果爆破的是管理后台</p><p>账号是admin&#x2F;adminstrator&#x2F;root的几率比较高</p><p>可以使用三个账号加一个密码来确认账号</p><h3 id="暴力破解的绕过和防范"><a href="#暴力破解的绕过和防范" class="headerlink" title="暴力破解的绕过和防范"></a>暴力破解的绕过和防范</h3><ul><li><p>暴力破解之不安全的验证码分析</p><ul><li>on client</li><li>on server</li></ul></li><li><p>Token可以防暴力破解码</p></li><li><p>暴力破解常见的防范措施</p></li></ul><p>我们一般用验证码来做什么？</p><ul><li>登录暴力破解</li><li>防止机器恶意注册</li></ul><p>验证码的认证流程</p><ul><li>客户端request登录页面，后台生成验证码<ul><li>后台使用算法生成验证码，并将图片response给客户端</li><li>同时将算法生成的值全局赋值存到SESSION中</li></ul></li><li>校验验证码<ul><li>客户端将认证信息和验证码一同提交</li><li>后台对提交的验证码与SESSION里面的进行比较</li></ul></li><li>客户端重新刷新页面，再次生成新的验证码<ul><li>验证码算法中一般包含随机函数，所以每次刷新验证码都会改变</li></ul></li></ul><h3 id="不安全的验证码-on-client常见问题"><a href="#不安全的验证码-on-client常见问题" class="headerlink" title="不安全的验证码-on client常见问题"></a>不安全的验证码-on client常见问题</h3><ul><li>使用前端js实现验证码（纸老虎）</li><li>将验证码在cookie中泄露，任意被获取</li><li>将验证码在前端源代码中泄露，容易被获取</li></ul><h3 id="不安全的验证码-on-server常见问题"><a href="#不安全的验证码-on-server常见问题" class="headerlink" title="不安全的验证码-on server常见问题"></a>不安全的验证码-on server常见问题</h3><ul><li>验证码在后台不过期，导致可以长期被使用</li><li>验证码校验不严格格，逻辑出现问题</li><li>验证码设计的太过简单和有规律，容易被猜解</li></ul><h2 id="XSS跨站脚本漏洞"><a href="#XSS跨站脚本漏洞" class="headerlink" title="XSS跨站脚本漏洞"></a>XSS跨站脚本漏洞</h2><h3 id="跨站脚本漏洞概述"><a href="#跨站脚本漏洞概述" class="headerlink" title="跨站脚本漏洞概述"></a>跨站脚本漏洞概述</h3><ul><li>XSS漏洞一致被评估为web漏洞中危害比较大的漏洞，在OWASP TOP10的排名中一直属于前三位</li><li>XSS是发生在web前端的漏洞，所以其危害的对象也主要是前端用户</li><li>XSS老可以用来进行钓鱼攻击、前端JS挖矿、用户cookie获取。甚至可以结合浏览器自身的老对用户主机进行远端控制等</li></ul><p><img src="https://blog-1258155859.cos.ap-guangzhou.myqcloud.com/imgSnipaste_2022-09-08_19-45-17.png"></p><h3 id="跨站脚本漏洞常见类型"><a href="#跨站脚本漏洞常见类型" class="headerlink" title="跨站脚本漏洞常见类型"></a>跨站脚本漏洞常见类型</h3><p>危害：存储型 &gt; 反射型 &gt; DOM型</p><ul><li>存储型：交互的数据会被存在数据库里面，永久性存储，一般出现在留言板，注册页面等</li><li>反射型：交互的数据一般不会被存储在数据库里面，一次性，一般出现在查询类页面等</li><li>DOM型：不与后台服务器数据交互，是一种通过DOM操作前端代码输出的时候产生的问题，一次性也属于反射型</li></ul><h3 id="XSS漏洞形成的原因"><a href="#XSS漏洞形成的原因" class="headerlink" title="XSS漏洞形成的原因"></a>XSS漏洞形成的原因</h3><p>形成XSS漏洞的主要原因是程序对输入和输出的控制不够严格，导致精心构造的脚本输入后，再输到前端时被浏览器当作有效代码执行。</p><h3 id="跨站脚本漏洞测试流程"><a href="#跨站脚本漏洞测试流程" class="headerlink" title="跨站脚本漏洞测试流程"></a>跨站脚本漏洞测试流程</h3><ul><li>在目标站点上找到输入点，比如查询j接口，留言板等</li><li>输入一组“特殊字符 + 唯一识别字符”，点击提交后，查看返回的源码，是否有做对应的处理</li><li>通过搜索定位到唯一字符，结合唯一字符前后语法确认是否可以构造执行js的条件（构造闭合）</li><li>提交构造的脚本代码（以及各种绕过姿势），看是否可以成功执行，如果可以成功执行则证明存在XSS漏洞</li></ul><p>TISP：</p><ul><li>一般查询接口容易出现反射型XSS，留言板容易出现存储型XSS</li><li>由于后台可能存在过滤措施，构造的script可能会被过滤掉，而无法生效，或者环境限制了执行（浏览器）</li><li>通过不同变化的script，尝试绕过后台过滤机制</li></ul><p>GET型XSS漏洞可以直接利用URL地址</p><h3 id="XSS绕过"><a href="#XSS绕过" class="headerlink" title="XSS绕过"></a>XSS绕过</h3><ul><li><p>前端绕过，直接抓包重放，或者修改前端代码</p></li><li><p>大小写，比如：<SCRIPT>aLeRT(111)<sCript></p></li><li><p>拼凑：<scri<script>pt>alert(111)</script>scri</script>pt&gt;</p></li><li><p>使用注释进行干扰：&lt;scri<!--text-->pt&gt;alert(111)&lt;&#x2F;sc<!--text-->ript&gt;</p></li><li><p>编码</p></li><li><p>绕过herf：<a href = javascript:alert(111>javascript:alert(111))</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> web渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaSE笔记(二)</title>
      <link href="/2022/10/20/JavaSE%E7%AC%94%E8%AE%B0(%E4%BA%8C)/"/>
      <url>/2022/10/20/JavaSE%E7%AC%94%E8%AE%B0(%E4%BA%8C)/</url>
      
        <content type="html"><![CDATA[<h1 id="Java对象和多态-（面向对象）"><a href="#Java对象和多态-（面向对象）" class="headerlink" title="Java对象和多态 （面向对象）"></a>Java对象和多态 （面向对象）</h1><h2 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h2><p>面向对象程序设计(Object Oriented Programming)</p><p>对象基于类创建，类相当于一个模板，对象就是根据模板创建出来的实体（就像做月饼，我们要做一个月饼首先需要一个模具，模具就是我们的类，而做出来的月饼，就是类的实现，也叫做对象），类是抽象的数据类型，并不能代表某一个具体的事物，类是对象的一个模板。类具有自己的属性，包括成员变量、成员方法等，我们可以调用类的成员方法来让类进行一些操作。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">System.out.println(<span class="string">&quot;你输入了：&quot;</span>+str);</span><br><span class="line">sc.close();</span><br></pre></td></tr></table></figure><p>所有的对象，都需要通过<code>new</code>关键字创建，基本数据类型不是对象！Java不是纯面对对象语言！</p><p>不是基本类型的变量，都是引用类型，引用类型变量代表一个对象，而基本数据类型变量，保存的是基本数据类型的值，我们可以通过引用来对对象进行操作。（最好不要理解为引用指向对象的地址，初学者不要谈内存，学到JVM时再来讨论）</p><p>对象占用的内存由JVM统一管理，不需要手动释放内存，当一个对象不再使用时（比如失去引用或是离开了作用域）会被JVM自动清理，内存管理更方便！</p><hr><h2 id="类的基本结构"><a href="#类的基本结构" class="headerlink" title="类的基本结构"></a>类的基本结构</h2><p>为了快速掌握，我们自己创建一个自己的类，创建的类文件名称应该和类名一致。</p><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>在类中，可以包含许多的成员变量，也叫成员属性，成员字段(field)通过<code>.</code>来访问我们类中的成员变量，我们可以通过类创建的对象来访问和修改这些变量。成员变量是属于对象的！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">    test.name = <span class="string">&quot;奥利给&quot;</span>;</span><br><span class="line">    System.out.println(test.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成员变量默认带有初始值，也可以自己定义初始值。</p><h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><p>我们之前的学习中接触过方法(Method)吗？主方法！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="comment">//Body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法是语句的集合，是为了完成某件事情而存在的。完成某件事情，可以有结果，也可以做了就做了，不返回结果。比如计算两个数字的和，我们需要得到计算后的结果，所以说方法需要有返回值；又比如，我们只想吧数字打印在控制台，只需要打印就行，不用给我结果，所以说方法不需要有返回值。</p><h4 id="方法的定义和使用"><a href="#方法的定义和使用" class="headerlink" title="方法的定义和使用"></a>方法的定义和使用</h4><p>在类中，我们可以定义自己的方法，格式如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[返回值类型] 方法名称([参数])&#123;</span><br><span class="line">  <span class="comment">//方法体</span></span><br><span class="line">  <span class="keyword">return</span> 结果;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>返回值类型：可以是引用类型和基本类型，还可以是void，表示没有返回值</li><li>方法名称：和标识符的规则一致，和变量一样，规范小写字母开头！</li><li>参数：例如方法需要计算两个数的和，那么我们就要把两个数到底是什么告诉方法，那么它们就可以作为参数传入方法</li><li>方法体：方法具体要干的事情</li><li>结果：方法执行的结果通过return返回（如果返回类型为void，可以省略return）</li></ul><p>非void方法中，<code>return</code>关键字不一定需要放在最后，但是一定要保证方法在任何情况下都具有返回值！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(a &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">//缺少retrun语句！</span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>return</code>也能用来提前结束整个方法，无论此时程序执行到何处，无论return位于哪里，都会立即结束个方法！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">       <span class="keyword">if</span>(i == <span class="number">1</span>) <span class="keyword">return</span>;   <span class="comment">//在循环内返回了！和break区别？</span></span><br><span class="line">   &#125;</span><br><span class="line">   System.out.println(<span class="string">&quot;淦&quot;</span>);   <span class="comment">//还会到这里吗？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传入方法的参数，如果是基本类型，会在调用方法的时候，对参数的值进行复制，方法中的参数变量，不是我们传入的变量本身！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Test</span>().swap(a, b);</span><br><span class="line">  System.out.println(<span class="string">&quot;a=&quot;</span>+a+<span class="string">&quot;, b=&quot;</span>+b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;  <span class="comment">//传递的仅仅是值而已！</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a;</span><br><span class="line">  a = b;</span><br><span class="line"> b = temp;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传入方法的参数，如果是引用类型，那么传入的依然是该对象的引用！（类似于C语言的指针）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"> String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(B b)</span>&#123;  <span class="comment">//传递的是对象的引用，而不是值</span></span><br><span class="line">    System.out.println(b.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">  <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">  b.name = <span class="string">&quot;lbw&quot;</span>;</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">A</span>().test(b);</span><br><span class="line">  System.out.println(<span class="string">&quot;a=&quot;</span>+a+<span class="string">&quot;, b=&quot;</span>+b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法之间可以相互调用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="comment">//xxxx</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span>&#123;</span><br><span class="line">  a();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当方法在自己内部调用自己时，称为递归调用（递归很危险，慎重！）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">a</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成员方法和成员变量一样，是属于对象的，只能通过对象去调用！</p><hr><h3 id="对象设计练习"><a href="#对象设计练习" class="headerlink" title="对象设计练习"></a>对象设计练习</h3><ul><li>学生应该具有以下属性：名字、年龄</li><li>学生应该具有以下行为：学习、运动、说话</li></ul><hr><h3 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h3><p>一个类中可以包含多个同名的方法，但是需要的形式参数不一样。（补充：形式参数就是定义方法需要的参数，实际参数就传入的参数）方法的返回类型，可以相同，也可以不同，但是仅返回类型不同，是不允许的！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">a</span><span class="params">()</span>&#123;   <span class="comment">//原本的方法</span></span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">a</span><span class="params">(<span class="type">int</span> i)</span>&#123;  <span class="comment">//ok，形参不同</span></span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">a</span><span class="params">(<span class="type">byte</span> i)</span>&#123;  <span class="comment">//ok，返回类型和形参都不同</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span>&#123;  <span class="comment">//错误，仅返回值类型名称不同不能重载</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们就可以使用不同的参数，但是支持调用同样的方法，执行一样的逻辑：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;   <span class="comment">//只有int支持，不灵活！</span></span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">double</span> <span class="title function_">sum</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span>&#123;  <span class="comment">//重写一个double类型的，就支持小数计算了</span></span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们有很多种重写的方法，那么传入实参后，到底进了哪个方法呢？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">a</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了int&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">a</span><span class="params">(<span class="type">short</span> i)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了short&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">a</span><span class="params">(<span class="type">long</span> i)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了long&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">a</span><span class="params">(<span class="type">char</span> i)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了char&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">a</span><span class="params">(<span class="type">double</span> i)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了double&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">a</span><span class="params">(<span class="type">float</span> i)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了float&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        test.a(<span class="number">1</span>);   <span class="comment">//直接输入整数</span></span><br><span class="line">        test.a(<span class="number">1.0</span>);  <span class="comment">//直接输入小数</span></span><br><span class="line"></span><br><span class="line">        <span class="type">short</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        test.a(s);  <span class="comment">//会对号入座吗？</span></span><br><span class="line">        test.a(<span class="number">1.0F</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>构造方法（构造器）没有返回值，也可以理解为，返回的是当前对象的引用！每一个类都默认自带一个无参构造方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//反编译结果</span></span><br><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">()</span> &#123;    <span class="comment">//即使你什么都不编写，也自带一个无参构造方法，只是默认是隐藏的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译其实就是把我们编译好的class文件变回Java源代码。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();  <span class="comment">//实际上存在Test()这个的方法，new关键字就是用来创建并得到引用的</span></span><br><span class="line"><span class="comment">// new + 你想要使用的构造方法</span></span><br></pre></td></tr></table></figure><p>这种方法没有写明返回值，但是每个类都必须具有这个方法！只有调用类的构造方法，才能创建类的对象！</p><p>类要在一开始准备的所有东西，都会在构造方法里面执行，完成构造方法的内容后，才能创建出对象！</p><p>一般最常用的就是给成员属性赋初始值：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    </span><br><span class="line">    Student()&#123;</span><br><span class="line">        name = <span class="string">&quot;伞兵一号&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以手动指定有参构造，当遇到名称冲突时，需要用到this关键字</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    Student(String name)&#123;   <span class="comment">//形参和类成员变量冲突了，Java会优先使用形式参数定义的变量！</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;  <span class="comment">//通过this指代当前的对象属性，this就代表当前对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//idea 右键快速生成！</span></span><br></pre></td></tr></table></figure><p>注意，this只能用于指代当前对象的内容，因此，只有属于对象拥有的部分才可以使用this，也就是说，只能在类的成员方法中使用this，不能在静态方法中使用this关键字。</p><p>在我们定义了新的有参构造之后，默认的无参构造会被覆盖！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//反编译后依然只有我们定义的有参构造！</span></span><br></pre></td></tr></table></figure><p>如果同时需要有参和无参构造，那么就需要用到方法的重载！手动再去定义一个无参构造。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    Student()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Student(String name)&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成员变量的初始化始终在构造方法执行之前</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;sadasa&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Student()&#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态变量和静态方法"><a href="#静态变量和静态方法" class="headerlink" title="静态变量和静态方法"></a>静态变量和静态方法</h3><p>静态变量和静态方法是类具有的属性（后面还会提到静态类、静态代码块），也可以理解为是所有对象共享的内容。我们通过使用<code>static</code>关键字来声明一个变量或一个方法为静态的，一旦被声明为静态，那么通过这个类创建的所有对象，操作的都是同一个目标，也就是说，对象再多，也只有这一个静态的变量或方法。那么，一个对象改变了静态变量的值，那么其他的对象读取的就是被改变的值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">s1.a = <span class="number">10</span>;</span><br><span class="line"><span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">System.out.println(s2.a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不推荐使用对象来调用，被标记为静态的内容，可以直接通过<code>类名.xxx</code>的形式访问</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   Student.a = <span class="number">10</span>;</span><br><span class="line">   System.out.println(Student.a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简述类加载机制"><a href="#简述类加载机制" class="headerlink" title="简述类加载机制"></a>简述类加载机制</h4><p>类并不是在一开始就全部加载好，而是在需要时才会去加载（提升速度）以下情况会加载类：</p><ul><li>访问类的静态变量，或者为静态变量赋值</li><li>new 创建类的实例（隐式加载）</li><li>调用类的静态方法</li><li>子类初始化时</li><li>其他的情况会在讲到反射时介绍</li></ul><p>所有被标记为静态的内容，会在类刚加载的时候就分配，而不是在对象创建的时候分配，所以说静态内容一定会在第一个对象初始化之前完成加载。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> test();  <span class="comment">//直接调用静态方法，只能调用静态方法</span></span><br><span class="line"></span><br><span class="line">    Student()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造类对象&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">()</span>&#123;   <span class="comment">//静态方法刚加载时就有了</span></span><br><span class="line">        System.out.println(<span class="string">&quot;初始化变量a&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思考：下面这种情况下，程序能正常运行吗？如果能，会输出什么内容？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> test();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Student.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义和赋值是两个阶段，在定义时会使用默认值（上面讲的，类的成员变量会有默认值）定义出来之后，如果发现有赋值语句，再进行赋值，而这时，调用了静态方法，所以说会先去加载静态方法，静态方法调用时拿到a，而a这时仅仅是刚定义，所以说还是初始值，最后得到0</p><h3 id="代码块和静态代码块"><a href="#代码块和静态代码块" class="headerlink" title="代码块和静态代码块"></a>代码块和静态代码块</h3><p>代码块在对象创建时执行，也是属于类的内容，但是它在构造方法执行之前执行（和成员变量初始值一样），且每创建一个对象时，只执行一次！（相当于构造之前的准备工作）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Student()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态代码块和上面的静态方法和静态变量一样，在类刚加载时就会调用；</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        a = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Student.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="String和StringBuilder类"><a href="#String和StringBuilder类" class="headerlink" title="String和StringBuilder类"></a>String和StringBuilder类</h3><p>字符串类是一个比较特殊的类，他是Java中唯一重载运算符的类！(Java不支持运算符重载，String是特例)</p><p>String的对象直接支持使用<code>+</code>或<code>+=</code>运算符来进行拼接，并形成新的String对象！（String的字符串是不可变的！）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;dasdsa&quot;</span>, b = <span class="string">&quot;dasdasdsa&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">l</span> <span class="operator">=</span> a+b;</span><br><span class="line">System.out.println(l);</span><br></pre></td></tr></table></figure><p>大量进行字符串的拼接似乎不太好，编译器是很聪明的，String的拼接有可能会被编译器优化为StringBuilder来减少对象创建（对象频繁创建时很费时间同时占内存的！）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String result=<span class="string">&quot;String&quot;</span>+<span class="string">&quot;and&quot;</span>; <span class="comment">//会被优化成一句！</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1=<span class="string">&quot;String&quot;</span>;</span><br><span class="line">String str2=<span class="string">&quot;and&quot;</span>;</span><br><span class="line">String result=str1+str2;</span><br><span class="line"><span class="comment">//变量随时可变，在编译时无法确定result的值，那么只能在运行时再去确定</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1=<span class="string">&quot;String&quot;</span>;</span><br><span class="line">String str2=<span class="string">&quot;and&quot;</span>;</span><br><span class="line">String result=(<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(String.valueOf(str1))).append(str2).toString();</span><br><span class="line"><span class="comment">//使用StringBuilder，会采用类似于第一种实现，显然会更快！</span></span><br></pre></td></tr></table></figure><p>StringBuilder也是一个类，但是它能够存储可变长度的字符串！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">builder</span><br><span class="line">       .append(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">       .append(<span class="string">&quot;bc&quot;</span>)</span><br><span class="line">       .append(<span class="string">&quot;d&quot;</span>);   <span class="comment">//链式调用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> builder.toString();</span><br><span class="line">System.out.println(str);</span><br></pre></td></tr></table></figure><hr><h2 id="包和访问控制"><a href="#包和访问控制" class="headerlink" title="包和访问控制"></a>包和访问控制</h2><h3 id="包声明和导入"><a href="#包声明和导入" class="headerlink" title="包声明和导入"></a>包声明和导入</h3><p>包其实就是用来区分类位置的东西，也可以用来将我们的类进行分类，类似于C++中的namespace！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>包其实是文件夹，比如com.test就是一个com文件夹中包含一个test文件夹，再包含我们Test类。</p><p>一般包按照个人或是公司域名的规则倒过来写 <code>顶级域名.一级域名.二级域名</code> <code>com.java.xxxx</code></p><p>如果需要使用其他包里面的类，那么我们需要<code>import</code>（类似于C&#x2F;C++中的include）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.test.Student;</span><br></pre></td></tr></table></figure><p>也可以导入包下的全部（一般导入会由编译器自带帮我们补全，但是一定要记得我们需要导包！）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.test.*</span><br></pre></td></tr></table></figure><p>Java默认为我们导入了以下的包，不需要去声明</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.*</span><br></pre></td></tr></table></figure><h3 id="静态导入"><a href="#静态导入" class="headerlink" title="静态导入"></a>静态导入</h3><p>静态导入可以直接导入某个类的静态方法或者是静态变量，导入后，相当于这个方法或是类在定义在当前类中，可以直接调用该方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.test.ui.Student.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态导入不会进行类的初始化！</p><h3 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h3><p>Java支持对类属性访问的保护，也就是说，不希望外部类访问类中的属性或是方法，只允许内部调用，这种情况下我们就需要用到权限控制符。</p><p>![image-20210819160939950](&#x2F;Users&#x2F;nagocoler&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20210819160939950.png)</p><p>权限控制符可以声明在方法、成员变量、类前面，一旦声明private，只能类内部访问！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;   <span class="comment">//具有私有访问权限，只能类内部访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    System.out.println(s.a);  <span class="comment">//还可以访问吗？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和文件名称相同的类，只能是public，并且一个java文件中只能有一个public class！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Student.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;   <span class="comment">//不能添加权限修饰符！只能是default</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h2><p>假设出现一种情况，我想记录100个数字，定义100个变量还可行吗？</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimgs.itxueyuan.com%2FCgq2xl329g-Adz0uAACwgSFkMho326.png&refer=http%3A%2F%2Fimgs.itxueyuan.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1632192902&t=7a6d67fc01d0e3ea7816adf951c49605" alt="img"></p><p>我们可以使用到数组，数组是相同类型数据的有序集合。数组可以代表任何相同类型的一组内容（包括引用类型和基本类型）其中存放的每一个数据称为数组的一个元素，数组的下标是从0开始，也就是第一个元素的索引是0！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];  <span class="comment">//需要new关键字来创建！</span></span><br><span class="line">String[] arr2 = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p>数组本身也是类（编程不可见，C++写的），不是基本数据类型！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">System.out.println(arr.length);   <span class="comment">//数组有成员变量！</span></span><br><span class="line">System.out.println(arr.toString());   <span class="comment">//数组有成员方法！</span></span><br></pre></td></tr></table></figure><h3 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h3><p>一维数组中，元素是依次排列的（线性），每个数组元素可以通过下标来访问！声明格式如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">类型[] 变量名称 = <span class="keyword">new</span> 类型[数组大小];</span><br><span class="line">类型 变量名称n = <span class="keyword">new</span> 类型[数组大小];  <span class="comment">//支持C语言样式，但不推荐！</span></span><br><span class="line"></span><br><span class="line">类型[] 变量名称 = <span class="keyword">new</span> 类型[]&#123;...&#125;;  <span class="comment">//静态初始化（直接指定值和大小）</span></span><br><span class="line">类型[] 变量名称 = &#123;...&#125;;   <span class="comment">//同上，但是只能在定义时赋值</span></span><br></pre></td></tr></table></figure><p> 创建出来的数组每个元素都有默认值（规则和类的成员变量一样，C语言创建的数组需要手动设置默认值），我们可以通过下标去访问：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">626</span>;</span><br><span class="line">System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">System.out.println(arr[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><p>我们可以通过<code>数组变量名称.length</code>来获取当前数组长度：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">System.out.println(arr.length);  <span class="comment">//打印length成员变量的值</span></span><br></pre></td></tr></table></figure><p>数组在创建时，就固定长度，不可更改！访问超出数组长度的内容，会出现错误！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] arr = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">10</span>];</span><br><span class="line">System.out.println(arr[<span class="number">10</span>]);  <span class="comment">//出现异常！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Exception in thread &quot;main&quot; java.lang.ArrayIndexOutOfBoundsException: 11</span></span><br><span class="line"><span class="comment">//at com.test.Application.main(Application.java:7)</span></span><br></pre></td></tr></table></figure><p>思考：能不能直接修改length的值来实现动态扩容呢？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">arr.length = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>数组做实参，因为数组也是类，所以形参得到的是数组的引用而不是复制的数组，操作的依然是数组对象本身</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    test(arr);</span><br><span class="line">    System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">2934</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h3><p>如果我们想要快速打印数组中的每一个元素，又怎么办呢？</p><h4 id="传统for循环"><a href="#传统for循环" class="headerlink" title="传统for循环"></a>传统for循环</h4><p>我们很容易就联想到for循环</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">   System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h4><p>传统for循环虽然可控性高，但是不够省事，要写一大堆东西，有没有一种省事的写法呢？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : arr) &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>foreach属于增强型的for循环，它使得代码更简洁，同时我们能直接拿到数组中的每一个数字。</p><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><p>二维数组其实就是存放数组的数组，每一个元素都存放一个数组的引用，也就相当于变成了一个平面。</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Ffile.elecfans.com%2Fweb1%2FM00%2FDD%2F01%2Fo4YBAGASjymAK8QIAADiOdWkSVA342.jpg&refer=http%3A%2F%2Ffile.elecfans.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1632204192&t=52381354d190d09899776f9bb868ef3e" alt="img"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//三行两列</span></span><br><span class="line"><span class="type">int</span>[][] arr = &#123; &#123;<span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">                &#123;<span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">                &#123;<span class="number">5</span>, <span class="number">6</span>&#125;&#125;;</span><br><span class="line">System.out.println(arr[<span class="number">2</span>][<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><p>二维数组的遍历同一维数组一样，只不过需要嵌套循环！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123; &#123;<span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">                           &#123;<span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">                           &#123;<span class="number">5</span>, <span class="number">6</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">          System.out.println(arr[i][j]);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>不止二维数组，还存在三维数组，也就是存放数组的数组的数组，原理同二维数组一样，逐级访问即可。</p><h3 id="可变长参数"><a href="#可变长参数" class="headerlink" title="可变长参数"></a>可变长参数</h3><p>可变长参数其实就是数组的一种应用，我们可以指定方法的形参为一个可变长参数，要求实参可以根据情况动态填入0个或多个，而不是固定的数量</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     test(<span class="string">&quot;AAA&quot;</span>, <span class="string">&quot;BBB&quot;</span>, <span class="string">&quot;CCC&quot;</span>);    <span class="comment">//可变长，最后都会被自动封装成一个数组</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(String... test)</span>&#123;</span><br><span class="line">     System.out.println(test[<span class="number">0</span>]);    <span class="comment">//其实参数就是一个数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于是数组，所以说只能使用一种类型的可变长参数，并且可变长参数只能放在最后一位！</p><h3 id="实战：三大基本排序算法"><a href="#实战：三大基本排序算法" class="headerlink" title="实战：三大基本排序算法"></a>实战：三大基本排序算法</h3><p>现在我们有一个数组，但是数组里面的数据是乱序排列的，如何使它变得有序？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">8</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br></pre></td></tr></table></figure><p>排序是编程的一个重要技能，掌握排序算法，你的技术才能更上一层楼，很多的项目都需要用到排序！三大排序算法：</p><ul><li>冒泡排序</li></ul><p>冒泡排序就是冒泡，其实就是不断使得我们无序数组中的最大数向前移动，经历n轮循环逐渐将每一个数推向最前。</p><ul><li>插入排序</li></ul><p>插入排序其实就跟我们打牌是一样的，我们在摸牌的时候，牌堆是乱序的，但是我们一张一张摸到手中进行排序，使得它变成了有序的！</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg1.jjhgame.com%2Fstatic_data%2Fnewshelp%2F113_5c08e82d2ac8b.jpg&refer=http%3A%2F%2Fimg1.jjhgame.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1632208529&t=f3fb9be4dce91c6364f5ec4f9faafc94" alt="img"></p><ul><li>选择排序</li></ul><p>选择排序其实就是每次都选择当前数组中最大的数排到最前面！</p><hr><h2 id="封装、继承和多态"><a href="#封装、继承和多态" class="headerlink" title="封装、继承和多态"></a>封装、继承和多态</h2><p>封装、继承和多态是面向对象编程的三大特性。</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装的目的是为了保证变量的安全性，使用者不必在意具体实现细节，而只是通过外部接口即可访问类的成员，如果不进行封装，类中的实例变量可以直接查看和修改，可能给整个代码带来不好的影响，因此在编写类时一般将成员变量私有化，外部类需要同getter和setter方法来查看和设置变量。</p><p>设想：学生小明已经创建成功，正常情况下能随便改他的名字和年龄吗？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，外部现在只能通过调用我定义的方法来获取成员属性，而我们可以在这个方法中进行一些额外的操作，比如小明可以修改名字，但是名字中不能包含”小”这个字。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(name.contains(<span class="string">&quot;小&quot;</span>)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单独给外部开放设置名称的方法，因为我还需要做一些额外的处理，所以说不能给外部直接操作成员变量的权限！</p><p>封装思想其实就是把实现细节给隐藏了，外部只需知道这个方法是什么作用，而无需关心实现。</p><p>封装就是通过访问权限控制来实现的。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承属于非常重要的内容，在定义不同类的时候存在一些相同属性，为了方便使用可以将这些共同属性抽象成一个父类，在定义其他子类时可以继承自该父类，减少代码的重复定义，子类可以使用父类中<strong>非私有</strong>的成员。</p><p>现在学生分为两种，艺术生和体育生，他们都是学生的分支，但是他们都有自己的方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SportsStudent</span> <span class="keyword">extends</span> <span class="title class_">Student</span>&#123;   <span class="comment">//通过extends关键字来继承父类</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SportsStudent</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, age);   <span class="comment">//必须先通过super关键字（指代父类），实现父类的构造方法！</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exercise</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我超勇的！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArtStudent</span> <span class="keyword">extends</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArtStudent</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">art</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;随手画个毕加索！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类具有父类的全部属性，protected可见但外部无法使用（包括<code>private</code>属性，不可见，无法使用），同时子类还能有自己的方法。继承只能继承一个父类，不支持多继承！</p><p>每一个子类必须定义一个实现父类构造方法的构造方法，也就是需要在构造方法开始使用<code>super()</code>，如果父类使用的是默认构造方法，那么子类不用手动指明。</p><p>所有类都默认继承自Object类，除非手动指定类型，但是依然改变不了最顶层的父类是Object类。所有类都包含Object类中的方法，比如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>;</span><br><span class="line">System.out.println(obj.hashCode());  <span class="comment">//求对象的hashcode，默认是对象的内存地址</span></span><br><span class="line">System.out.println(obj.equals(obj));  <span class="comment">//比较对象是否相同，默认比较的是对象的内存地址，也就是等同于 ==</span></span><br><span class="line">System.out.println(obj.toString());  <span class="comment">//将对象转换为字符串，默认生成对象的类名称+hashcode</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于Object类的其他方法，我们会在Java多线程中再来提及。</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态是同一个行为具有多个不同表现形式或形态的能力。也就是同样的方法，由于实现类不同，执行的结果也不同！</p><h4 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a>方法的重写</h4><p>我们之前学习了方法的重载，方法的重写和重载是不一样的，重载是原有的方法逻辑不变的情况下，支持更多参数的实现，而重写是直接覆盖原有方法！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父类中的study</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;学习&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类中的study</span></span><br><span class="line"><span class="meta">@Override</span>  <span class="comment">//声明这个方法是重写的，但是可以不要，我们现阶段不接触</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;给你看点好康的&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次定义同样的方法后，父类的方法就被覆盖！子类还可以给父类方法提升访问权限！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     <span class="type">SportsStudent</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SportsStudent</span>(<span class="string">&quot;lbw&quot;</span>, <span class="number">20</span>);</span><br><span class="line">     student.study();   <span class="comment">//输出子类定义的内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思考：静态方法能被重写吗？</p><p>当我们在重写方法时，不仅想使用我们自己的逻辑，同时还希望执行父类的逻辑（也就是调用父类的方法）怎么办呢？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">super</span>.study();</span><br><span class="line">    System.out.println(<span class="string">&quot;给你看点好康的&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理，如果想访问父类的成员变量，也可以使用super关键字来访问，注意，子类可以具有和父类相同的成员变量！而在方法中访问的默认是 形参列表中 &gt; 当前类的成员变量 &gt; 父类成员变量</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTest</span><span class="params">(<span class="type">int</span> test)</span>&#123;</span><br><span class="line">    test = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">this</span>.test = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">super</span>.test = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="再谈类型转换"><a href="#再谈类型转换" class="headerlink" title="再谈类型转换"></a>再谈类型转换</h4><p>我们曾经学习过基本数据类型的类型转换，支持一种数据类型转换为另一种数据类型，而我们的类也是支持类型转换的（仅限于存在亲缘关系的类之间进行转换）比如子类可以直接向上转型：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SportsStudent</span>(<span class="string">&quot;lbw&quot;</span>, <span class="number">20</span>);  <span class="comment">//父类变量引用子类实例</span></span><br><span class="line">student.study();     <span class="comment">//得到依然是具体实现的结果，而不是当前类型的结果</span></span><br></pre></td></tr></table></figure><p>我们也可以把已经明确是由哪个类实现的父类引用，强制转换为对应的类型：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SportsStudent</span>(<span class="string">&quot;lbw&quot;</span>, <span class="number">20</span>);  <span class="comment">//是由SportsStudent进行实现的</span></span><br><span class="line"><span class="comment">//... do something...</span></span><br><span class="line"></span><br><span class="line"><span class="type">SportsStudent</span> <span class="variable">ps</span> <span class="operator">=</span> (SportsStudent)student;  <span class="comment">//让它变成一个具体的子类</span></span><br><span class="line">ps.sport();  <span class="comment">//调用具体实现类的方法</span></span><br></pre></td></tr></table></figure><p>这样的类型转换称为向下转型。</p><h4 id="instanceof关键字"><a href="#instanceof关键字" class="headerlink" title="instanceof关键字"></a>instanceof关键字</h4><p>那么我们如果只是得到一个父类引用，但是不知道它到底是哪一个子类的实现怎么办？我们可以使用instanceof关键字来实现，它能够进行类型判断！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(Student student)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (student <span class="keyword">instanceof</span> SportsStudent)&#123;</span><br><span class="line">        <span class="type">SportsStudent</span> <span class="variable">sportsStudent</span> <span class="operator">=</span> (SportsStudent) student;</span><br><span class="line">        sportsStudent.sport();</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (student <span class="keyword">instanceof</span> ArtStudent)&#123;</span><br><span class="line">        <span class="type">ArtStudent</span> <span class="variable">artStudent</span> <span class="operator">=</span> (ArtStudent) student;</span><br><span class="line">        artStudent.art();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过进行类型判断，我们就可以明确类的具体实现到底是哪个类！</p><p>思考：<code>student instanceof Student</code>的结果是什么？</p><h4 id="再谈final关键字"><a href="#再谈final关键字" class="headerlink" title="再谈final关键字"></a>再谈final关键字</h4><p>我们目前只知道<code>final</code>关键字能够使得一个变量的值不可更改，那么如果在类前面声明final，会发生什么？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;   <span class="comment">//类被声明为终态，那么它还能被继承吗</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类一旦被声明为终态，将无法再被继承，不允许子类的存在！而方法被声明为final呢？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>&#123;  <span class="comment">//还能重写吗</span></span><br><span class="line">    System.out.println(<span class="string">&quot;学习&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果类的成员属性被声明为final，那么必须在构造方法中或是在定义时赋初始值！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String name;   <span class="comment">//引用类型不允许再指向其他对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> age;    <span class="comment">//基本类型值不允许发生改变</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>学习完封装继承和多态之后，我们推荐在不会再发生改变的成员属性上添加final关键字，JVM会对添加了final关键字的属性进行优化！</p><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>类本身就是一种抽象，而抽象类，把类还要抽象，也就是说，抽象类可以只保留特征，而不保留具体呈现形态，比如方法可以定义好，但是我可以不去实现它，而是交由子类来进行实现！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;    <span class="comment">//抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>;  <span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过使用<code>abstract</code>关键字来表明一个类是一个抽象类，抽象类可以使用<code>abstract</code>关键字来表明一个方法为抽象方法，也可以定义普通方法，抽象方法不需要编写具体实现（无方法体）但是<strong>必须</strong>由子类实现（除非子类也是一个抽象类）！</p><p>抽象类由于不是具体的类定义，因此无法直接通过new关键字来创建对象！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>()&#123;    <span class="comment">//只能直接创建带实现的匿名内部类！</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，抽象类一般只用作继承使用！抽象类使得继承关系之间更加明确：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>&#123;   <span class="comment">//现在只能由子类编写，父类没有定义，更加明确了多态的定义！同一个方法多种实现！</span></span><br><span class="line">    System.out.println(<span class="string">&quot;给你看点好康的&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>接口甚至比抽象类还抽象，他只代表某个确切的功能！也就是只包含方法的定义，甚至都不是一个类！接口包含了一些列方法的具体定义，类可以实现这个接口，表示类支持接口代表的功能（类似于一个插件，只能作为一个附属功能加在主体上，同时具体实现还需要由主体来实现）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Eat</span> &#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过使用<code>interface</code>关键字来表明是一个接口（注意，这里class关键字被替换为了interface）接口只能包含<code>public</code>权限的<strong>抽象方法</strong>！（Java8以后可以有默认实现）我们可以通过声明<code>default</code>关键字来给抽象方法一个默认实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Eat</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//do something...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口中定义的变量，默认为public static final</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Eat</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个类可以实现很多个接口，但是不能理解为多继承！（实际上实现接口是附加功能，和继承的概念有一定出入，顶多说是多继承的一种替代方案）一个类可以附加很多个功能！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SportsStudent</span> <span class="keyword">extends</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Eat</span>, ...&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类通过<code>implements</code>关键字来声明实现的接口！每个接口之间用逗号隔开！</p><p>实现接口的类也能通过instanceof关键字判断，也支持向上和向下转型！</p><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>类中可以存在一个类！各种各样的长相怪异的代码就是从这里开始出现的！</p><h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p>我们的类中可以在嵌套一个类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;   <span class="comment">//类中定义的一个内部类</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成员内部类和成员变量和成员方法一样，都是属于对象的，也就是说，必须存在外部对象，才能创建内部类的对象！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">    Test.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> test.<span class="keyword">new</span> <span class="title class_">Inner</span>();   <span class="comment">//写法有那么一丝怪异，但是没毛病！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>静态内部类其实就和类中的静态变量和静态方法一样，是属于类拥有的，我们可以直接通过<code>类名.</code>去访问:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Test.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>.Inner();   <span class="comment">//不用再创建外部类对象了！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>对，你没猜错，就是和局部变量一样哒~</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反正我是没用过！内部类 -&gt; 累不累 -&gt; 反正我累了！</p><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>匿名内部类才是我们的重点，也是实现lambda表达式的原理！匿名内部类其实就是在new的时候，直接对接口或是抽象类的实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Eat</span> <span class="variable">eat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Eat</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">//DO something...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们不用单独去创建一个类来实现，而是可以直接在new的时候写对应的实现！但是，这样写，无法实现复用，只能在这里使用！</p><h4 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h4><p>读作<code>λ</code>表达式，它其实就是我们接口匿名实现的简化，比如说：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Eat</span> <span class="variable">eat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Eat</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">//DO something...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Eat</span> <span class="variable">eat</span> <span class="operator">=</span> () -&gt; &#123;&#125;;   <span class="comment">//等价于上述内容</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>lambda表达式（匿名内部类）只能访问外部的final类型或是隐式final类型的局部变量！</p><p>为了方便，JDK默认就为我们提供了专门写函数式的接口，这里只介绍Consumer</p><h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><p>假设现在我们想给小明添加一个状态（跑步、学习、睡觉），外部可以实时获取小明的状态：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String status;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStatus</span><span class="params">(String status)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.status = status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getStatus</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样会出现一个问题，如果我们仅仅是存储字符串，似乎外部可以不按照我们规则，传入一些其他的字符串。这显然是不够严谨的！</p><p>有没有一种办法，能够更好地去实现这样的状态标记呢？我们希望开发者拿到使用的就是我们定义好的状态，我们可以使用枚举类！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Status</span> &#123;</span><br><span class="line">    RUNNING, STUDY, SLEEP    <span class="comment">//直接写每个状态的名字即可，分号可以不打，但是推荐打上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用枚举类也非常方便，我们只需要直接访问即可</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Status status;</span><br><span class="line">  </span><br><span class="line"> <span class="comment">//...</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStatus</span><span class="params">(Status status)</span> &#123;   <span class="comment">//不再是String，而是我们指定的枚举类型</span></span><br><span class="line">        <span class="built_in">this</span>.status = status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Status <span class="title function_">getStatus</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;小明&quot;</span>, <span class="number">18</span>);</span><br><span class="line">    student.setStatus(Status.RUNNING);</span><br><span class="line">    System.out.println(student.getStatus());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举类型使用起来就非常方便了，其实枚举类型的本质就是一个普通的类，但是它继承自<code>Enum</code>类，我们定义的每一个状态其实就是一个<code>public static final</code>的Status类型成员变量！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Compiled from &quot;Status.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">com</span>.test.Status <span class="keyword">extends</span> <span class="title class_">java</span>.lang.Enum&lt;com.test.Status&gt; &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> com.test.Status RUNNING;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> com.test.Status STUDY;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> com.test.Status SLEEP;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> com.test.Status[] values();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> com.test.Status <span class="title function_">valueOf</span><span class="params">(java.lang.String)</span>;</span><br><span class="line">  <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然枚举类型是普通的类，那么我们也可以给枚举类型添加独有的成员方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Status</span> &#123;</span><br><span class="line">    RUNNING(<span class="string">&quot;睡觉&quot;</span>), STUDY(<span class="string">&quot;学习&quot;</span>), SLEEP(<span class="string">&quot;睡觉&quot;</span>);   <span class="comment">//无参构造方法被覆盖，创建枚举需要添加参数（本质就是调用的构造方法！）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;    <span class="comment">//枚举的成员变量</span></span><br><span class="line">    Status(String name)&#123;    <span class="comment">//覆盖原有构造方法（默认private，只能内部使用！）</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;   <span class="comment">//获取封装的成员变量</span></span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;小明&quot;</span>, <span class="number">18</span>);</span><br><span class="line">    student.setStatus(Status.RUNNING);</span><br><span class="line">    System.out.println(student.getStatus().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举类还自带一些继承下来的实用方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Status.valueOf(<span class="string">&quot;&quot;</span>)   <span class="comment">//将名称相同的字符串转换为枚举</span></span><br><span class="line">Status.values()   <span class="comment">//快速获取所有的枚举</span></span><br></pre></td></tr></table></figure><h2 id="基本类型包装类"><a href="#基本类型包装类" class="headerlink" title="基本类型包装类"></a>基本类型包装类</h2><p>Java并不是纯面向对象的语言，虽然Java语言是一个面向对象的语言，但是Java中的基本数据类型却不是面向对象的。在学习泛型和集合之前，基本类型的包装类是一定要讲解的内容！</p><p>我们的基本类型，如果想通过对象的形式去使用他们，Java提供的基本类型包装类，使得Java能够更好的体现面向对象的思想，同时也使得基本类型能够支持对象操作！</p><p><img src="https://img2018.cnblogs.com/blog/1504650/201901/1504650-20190122173636211-1359168032.png" alt="img"></p><ul><li>byte  -&gt;  Byte      </li><li>boolean  -&gt;  Boolean   </li><li>short  -&gt;  Short    </li><li>char  -&gt;  Character  </li><li>int -&gt; Integer    </li><li>long -&gt;  Long     </li><li>float -&gt; Float      </li><li>double -&gt; Double</li></ul><p>包装类实际上就行将我们的基本数据类型，封装成一个类（运用了封装的思想）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> value;   <span class="comment">//Integer内部其实本质还是存了一个基本类型的数据，但是我们不能直接操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Integer</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们操作的就是Integer对象而不是一个int基本类型了！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;   <span class="comment">//包装类型可以直接接收对应类型的数据，并变为一个对象！</span></span><br><span class="line">     System.out.println(i + i);    <span class="comment">//包装类型可以直接被当做一个基本类型进行操作！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自动装箱和拆箱"><a href="#自动装箱和拆箱" class="headerlink" title="自动装箱和拆箱"></a>自动装箱和拆箱</h4><p>那么为什么包装类型能直接使用一个具体值来赋值呢？其实依靠的是自动装箱和拆箱机制</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;    <span class="comment">//其实这里只是简写了而已</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> Integer.valueOf(<span class="number">1</span>);  <span class="comment">//编译后真正的样子</span></span><br></pre></td></tr></table></figure><p>调用valueOf来生成一个Integer对象！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)   <span class="comment">//注意，Java为了优化，有一个缓存机制，如果是在-128~127之间的数，会直接使用已经缓存好的对象，而不是再去创建新的！（面试常考）</span></span><br><span class="line">       <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);   <span class="comment">//返回一个新创建好的对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而如果使用包装类来进行运算，或是赋值给一个基本类型变量，会进行自动拆箱：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> Integer.valueOf(<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> i;    <span class="comment">//简写</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> i.intValue();   <span class="comment">//编译后实际的代码</span></span><br><span class="line">  </span><br><span class="line">  <span class="type">long</span> <span class="variable">c</span> <span class="operator">=</span> i.longValue();   <span class="comment">//其他类型也有！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然现在是包装类型了，那么我们还能使用<code>==</code>来判断两个数是否相等吗？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">28914</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">28914</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(i1 == i2);   <span class="comment">//实际上判断是两个对象是否为同一个对象（内存地址是否相同）</span></span><br><span class="line">    System.out.println(i1.equals(i2));   <span class="comment">//这个才是真正的值判断！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意IntegerCache带来的影响！</p><p>思考：下面这种情况结果会是什么？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">28914</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">28914</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(i1+<span class="number">1</span> == i2+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在集合类的学习中，我们还会继续用到我们的包装类型！</p><hr><h2 id="面向对象编程实战"><a href="#面向对象编程实战" class="headerlink" title="面向对象编程实战"></a>面向对象编程实战</h2><p>虽然我们学习了编程，但是我们不能一股脑的所有问题都照着编程的思维去解决，编程只是解决问题的一种手段，灵活的运用我们所学的知识，才是解决问题的最好办法！比如，求1到100所有数的和：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;   <span class="comment">//for循环暴力求解，简单，但是效率似乎低了一些</span></span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println((<span class="number">1</span> + <span class="number">100</span>) * <span class="number">50</span>);  <span class="comment">//高斯求和公式，利用数学，瞬间计算结果！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说到最后，其实数学和逻辑思维才是解决问题的最终办法！</p><h3 id="对象设计（面向对象、多态运用）"><a href="#对象设计（面向对象、多态运用）" class="headerlink" title="对象设计（面向对象、多态运用）"></a>对象设计（面向对象、多态运用）</h3><ul><li>设计一个Person抽象类，包含吃饭运动学习三种行为，分为工人、学生、老师三种职业。</li><li>设计设计一个接口<code>考试</code>，只有老师和学生会考试。</li><li>设计一个方法，模拟让人类进入考场，要求只有会考试的人才能进入，并且考试。</li></ul><h3 id="二分搜索（搜索算法）"><a href="#二分搜索（搜索算法）" class="headerlink" title="二分搜索（搜索算法）"></a>二分搜索（搜索算法）</h3><p>现在有一个有序数组（从小到大，数组长度 0 &lt; n &lt; 1000000）如何快速寻找我们想要的数在哪个位置，如果存在请返回下标，不存在返回<code>-1</code>即可。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">20</span>, <span class="number">22</span>, <span class="number">26</span>&#125;;   <span class="comment">//测试用例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="comment">//请在这里实现搜索算法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序（排序算法、递归分治）"><a href="#快速排序（排序算法、递归分治）" class="headerlink" title="快速排序（排序算法、递归分治）"></a>快速排序（排序算法、递归分治）</h3><p>（开始之前先介绍一下递归！）快速排序其实是一种排序执行效率很高的排序算法，它利用<strong>分治法</strong>来对待排序序列进行分治排序，它的思想主要是通过一趟排序将待排记录分隔成独立的两部分，其中的一部分比关键字小，后面一部分比关键字大，然后再对这前后的两部分分别采用这种方式进行排序，通过递归的运算最终达到整个序列有序。</p><p>快速排序就像它的名字一样，快速！在极端情况下，会退化成冒泡排序！</p><h3 id="0-x2F-1背包问题（回溯法、剪枝-x2F-动态规划优化）"><a href="#0-x2F-1背包问题（回溯法、剪枝-x2F-动态规划优化）" class="headerlink" title="0&#x2F;1背包问题（回溯法、剪枝&#x2F;动态规划优化）"></a>0&#x2F;1背包问题（回溯法、剪枝&#x2F;动态规划优化）</h3><p>给定 <code>n </code>件物品，每一个物品的重量为 <code>w[n]</code>，每个物品的价值为 <code>v[n]</code>。现挑选物品放入背包中，假定背包能承受的最大重量为 <code>capacity</code>，求装入物品的最大价值是多少?</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] w = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] v = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> <span class="number">8</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVASE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaSE笔记(一)</title>
      <link href="/2022/10/18/JavaSE%E7%AC%94%E8%AE%B0(%E4%B8%80)/"/>
      <url>/2022/10/18/JavaSE%E7%AC%94%E8%AE%B0(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<h1 id="Java语法规范"><a href="#Java语法规范" class="headerlink" title="Java语法规范"></a>Java语法规范</h1><p>所有的Java语句必须以<code>;</code>结尾！</p><p>无论是<code>()</code>、<code>[]</code>还是<code>&#123;&#125;</code>，所有的括号必须一一匹配！</p><p>主方法的代码只能写在<code>&#123;&#125;</code>中！</p><h1 id="Java基础语法（面向过程）"><a href="#Java基础语法（面向过程）" class="headerlink" title="Java基础语法（面向过程）"></a>Java基础语法（面向过程）</h1><p>在学习面向对象之前，我们需要了解面向过程的编程思维，如果你学习过C语言和Python就会很轻松！</p><h2 id="变量和关键字"><a href="#变量和关键字" class="headerlink" title="变量和关键字"></a>变量和关键字</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量就是一个可变的量，例如定义一个int类型的变量（int就是整数类型）：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">a = <span class="number">20</span>;</span><br><span class="line">a = <span class="number">30</span>;</span><br></pre></td></tr></table></figure><p>我们能够随意更改它的值，也就是说它的值是随时可变的，我们称为变量。变量可以是类的变量，也可以是方法内部的局部变量（我们现阶段主要用局部变量，类变量在面向对象再讲解）</p><p>变量和C语言中的变量不同，Java中的变量是存放在JVM管理的内存中，C语言的变量存放在内存（某些情况下需要手动释放内存，而Java会自动帮助我们清理变量占据的内存）Java和C++很类似，但是没有指针！Java也叫C++–</p><p>Java是强类型语言，只有明确定义了变量之后，你才能使用！一旦被指定某个数据类型，那么它将始终被认为是对应的类型（和JS不一样！）</p><p>定义一个变量的格式如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[类型] [标识符(名字)] = [初始值(可选)]</span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>注意：标识符不能为以下内容：</p><ul><li>标识符以由大小写字母、数字、下划线(_)和美元符号($)组成，但是不能以数字开头。</li><li>大小写敏感！</li><li>不能有空格、@、#、+、-、&#x2F; 等符号</li><li>应该使用有意义的名称，达到见名知意的目的，最好以小写字母开头</li><li>不可以是 true 和 false </li><li>不能与Java语言的关键字重名</li></ul><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>![image-20210817150135886](&#x2F;Users&#x2F;nagocoler&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20210817150135886.png)</p><p>包括基本数据类型、流程控制语句等，了解就行，不用去记，后面我们会一点一点带大家认识！</p><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>常量就是无法修改值的变量，常量的值，只能定义一次：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">a = <span class="number">10</span>;  <span class="comment">//报错！</span></span><br></pre></td></tr></table></figure><p>常量前面必须添加final关键字（C语言里面是const，虽然Java也有，但是不能使用！）</p><p>这只是final关键字的第一个用法，后面还会有更多的用法。</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>养成注释的好习惯，不然以后自己都看不懂自己的代码！注释包括单行注释和多行注释：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//我是单行注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 我是</span></span><br><span class="line"><span class="comment">* 多行注释</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//TODO 待做标记</span></span><br></pre></td></tr></table></figure><hr><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>Java中的数据类型分为基本数据类型和引用类型两大类，引用类型我们在面向对象时再提，基本数据类型是重点中的重点！首先我们需要了解有哪些类型。然后，我们需要知道的，并不是他们的精度如何，能够表示的范围有多大，而是为什么Java会给我们定义这些类型，计算机是怎么表示这些类型的，这样我们才能够更好的记忆他们的精度、表示的范围大小。所以，我们从计算机原理的角度出发，带领大家走进Java的基本数据类型。</p><p>这一部分稍微有点烧脑，但是是重中之重，如果你掌握了这些，任何相关的面试题都难不倒你！（如果你学习过计算机组成原理就很好理解了）</p><h3 id="计算机中的二进制表示"><a href="#计算机中的二进制表示" class="headerlink" title="计算机中的二进制表示"></a>计算机中的二进制表示</h3><p>在计算机中，所有的内容都是二进制形式表示。十进制是以10为进位，如9+1&#x3D;10；二进制则是满2进位（因为我们的计算机是电子的，电平信号只有高位和低位，你也可以暂且理解为通电和不通电，高电平代表1，低电平代表0，由于只有0和1，因此只能使用2进制表示我们的数字！）比如1+1&#x3D;10&#x3D;2^1+0，一个位也叫一个bit，8个bit称为1字节，16个bit称为一个字，32个bit称为一个双字，64个bit称为一个四字，我们一般采用字节来描述数据大小。</p><p>十进制的7 -&gt; 在二进制中为 111 &#x3D; 2^2 + 2^1 + 2^0</p><p>现在有4个bit位，最大能够表示多大的数字呢？</p><ul><li>最小：0000 &#x3D;&gt; 0</li><li>最大：1111 &#x3D;&gt; 2^3+2^2+2^1+2^0 &#x3D;&gt; 8 + 4 + 2 + 1 &#x3D; 15</li></ul><p>在Java中，无论是小数还是整数，他们都要带有符号（和C语言不同，C语言有无符号数）所以，首位就作为我们的符号位，还是以4个bit为例，首位现在作为符号位（1代表负数，0代表正数）：</p><ul><li>最小：1111 &#x3D;&gt; -(2^2+2^1+2^0) &#x3D;&gt; -7</li><li>最大：0111 &#x3D;&gt; +(2^2+2^1+2^0) &#x3D;&gt; +7 &#x3D;&gt; 7</li></ul><p>现在，我们4bit能够表示的范围变为了-7~+7，这样的表示方式称为原码。</p><h3 id="计算机中的加减法"><a href="#计算机中的加减法" class="headerlink" title="计算机中的加减法"></a>计算机中的加减法</h3><h4 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h4><p>虽然原码表示简单，但是原码在做加减法的时候，很麻烦！以4bit位为例：</p><p>1+(-1) &#x3D; 0001 + 1001 &#x3D; 怎么让计算机去计算？（虽然我们知道该去怎么算，但是计算机不知道！）</p><p>我们得创造一种更好的表示方式！于是我们引入了反码：</p><h4 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h4><ul><li>正数的反码是其本身</li><li>负数的反码是在其原码的基础上, 符号位不变，其余各个位取反</li></ul><p>经过上面的定义，我们再来进行加减法：</p><p>1+(-1) &#x3D; 0001 + 1110 &#x3D; 1111 &#x3D;&gt; -0 （直接相加，这样就简单多了！）</p><p>思考：1111代表-0，0000代表+0，在我们实数的范围内，0有正负之分吗？</p><ul><li>0既不是正数也不是负数，那么显然这样的表示依然不够合理！</li></ul><h4 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h4><p>根据上面的问题，我们引入了最终的解决方案，那就是补码，定义如下：</p><ul><li>正数的补码就是其本身 （不变！）</li><li>负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)</li></ul><p>其实现在就已经能够想通了，-0其实已经被消除了！我们再来看上面的运算：</p><p>1+(-1) &#x3D; 0001 + 1111 &#x3D; (1)0000 &#x3D;&gt; +0 （现在无论你怎么算，也不会有-0了！）</p><p>所以现在，4bit位能够表示的范围是：-8~+7（Java使用的就是补码！）</p><p><code>以上内容是重点， 是一定要掌握的知识，这些知识是你在面试中的最终防线！有了这些理论基础，无论面试题如何变换，都能够通过理论知识来破解</code></p><hr><h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><p>整数类型是最容易理解的类型！既然我们知道了计算机中的二进制数字是如何表示的，那么我们就可以很轻松的以二进制的形式来表达我们十进制的内容了。</p><p>在Java中，整数类型包括以下几个：</p><ul><li>byte 字节型 （8个bit，也就是1个字节）范围：-128~+127</li><li>short 短整形（16个bit，也就是2个字节）范围：-32768~+32767</li><li>int 整形（32个bit，也就是4个字节）最常用的类型！</li><li>long 长整形（64个bit，也就是8个字节）最后需要添加l或L</li></ul><p>long都装不下怎么办？BigInteger！</p><p>数字已经达到byte的最大值了，还能加吗？为了便于理解，以4bit为例：</p><p>0111 + 0001 &#x3D; 1000 &#x3D;&gt;  -8（你没看错，就是这样！）</p><p>整数还能使用8进制、16进制表示：</p><ul><li>十进制为15 &#x3D; 八进制表示为017 &#x3D; 十六进制表示为 0xF &#x3D; 二进制表示 1111 (代码里面不能使用二进制！)</li></ul><h3 id="字符类型和字符串"><a href="#字符类型和字符串" class="headerlink" title="字符类型和字符串"></a>字符类型和字符串</h3><p>在Java中，存在字符类型，它能够代表一个字符：</p><ul><li>char 字符型（16个bit，也就是2字节，它不带符号！）范围是0 ~ 65535</li><li>使用Unicode表示就是：\u0000 ~ \uffff</li></ul><p>字符要用单引号扩起来！比如 char c &#x3D; ‘淦’;</p><p>字符其实本质也是数字，但是这些数字通过编码表进行映射，代表了不同的字符，比如字符<code>&#39;A&#39;</code>的ASCII码就是数字<code>65</code>，所以，char类型其实可以转换为上面的整数类型。</p><p>Java的char采用Unicode编码表（不是ASCII编码！），Unicode编码表包含ASCII的所有内容，同时还包括了全世界的语言，ASCII只有1字节，而Unicode编码是2字节，能够代表65536种文字，足以包含全世界的文字了！（我们编译出来的字节码文件也是使用Unicode编码的，所以利用这种特性，其实Java支持中文变量名称、方法名称甚至是类名）</p><p>既然char只能代表一个字符，那怎么才能包含一句话呢？（关于数组，我们这里先不了解，数组我们放在面向对象章节讲解）</p><p>String就是Java中的字符串类型（注意，它是一个类，创建出来的字符串本质是一个对象，不是我们的基本类型）字符串就像它的名字一样，代表一串字符，也就是一句完整的话。</p><p>字符串用双引号括起来！比如：String str &#x3D; “一日三餐没烦恼”;</p><h3 id="小数类型"><a href="#小数类型" class="headerlink" title="小数类型"></a>小数类型</h3><p>小数类型比较难理解（比较难理解指的是原理，不是使用）首先来看看Java中的小数类型包含哪些：</p><ul><li>float 单精度浮点型 （32bit，4字节）</li><li>double 双精度浮点型（64bit，8字节）</li></ul><p>思考：小数的范围该怎么定义呢？我们首先要了解的是小数在计算机里面是如何存放的：</p><p>![image-20210817143234500](&#x2F;Users&#x2F;nagocoler&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20210817143234500.png)</p><p>根据国际标准 IEEE 754，任意一个二进制浮点数 V 可以表示成下面的形式：<br>V &#x3D; (-1)^S × M × 2^E<br>（1）(-1)^S 表示符号位，当 S&#x3D;0，V 为正数；当 S&#x3D;1，V 为负数。<br>（2）M 表示有效数字，大于等于 1，小于 2，但整数部分的 1 不变，因此可以省略。（例如尾数为1111010，那么M实际上就是1.111010，尾数首位必须是1，1后面紧跟小数点，如果出现0001111这样的情况，去掉前面的0，移动1到首位；题外话：随着时间的发展，IEEE 754标准默认第一位为1，故为了能够存放更多数据，就舍去了第一位，比如保存1.0101 的时候， 只保存 0101，这样能够多存储一位数据）<br>（3）2^E 表示指数位。（用于移动小数点）</p><p>比如： 对于十进制的 5.25 对应的二进制为：101.01，相当于：1.0101*2^2。所以，S 为 0，M 为 1.0101，E 为 2。所以，对于浮点类型，最大值和最小值不仅取决于符号和尾数，还有它的阶码。我们在这里就不去计算了，想了解的可以去搜索相关资料。</p><p>思考：就算double有64bit位数，但是依然存在精度限制，如果我要进行高精度的计算，怎么办？BigDecimal！</p><h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><p>布尔类型（boolean）只有<code>true</code>和<code>false</code>两种值，也就是要么为真，要么为假，布尔类型的变量通常用作流程控制判断语句。（C语言一般使用0表示false，除0以外的所有数都表示true）布尔类型占据的空间大小并未明确定义，而是根据不同的JVM会有不同的实现。</p><hr><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><p>隐式类型转换支持字节数小的类型自动转换为字节数大的类型，整数类型自动转换为小数类型，转换规则如下：</p><ul><li>byte→short(char)→int→long→float→double</li></ul><p>问题：为什么long比float大，还能转换为float呢？小数的存储规则让float的最大值比long还大，只是可能会丢失某些位上的精度！</p><p>所以，如下的代码就能够正常运行：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line"><span class="type">short</span> <span class="variable">s</span> <span class="operator">=</span> b;</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s;</span><br><span class="line"><span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> i;</span><br><span class="line"><span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> l;</span><br><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> f;</span><br><span class="line">System.out.println(d);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出 9.0</span></span><br></pre></td></tr></table></figure><h3 id="显示类型转换"><a href="#显示类型转换" class="headerlink" title="显示类型转换"></a>显示类型转换</h3><p>显示类型转换也叫做强制类型转换，也就是说，违反隐式转换的规则，牺牲精度强行进行类型转换。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> (<span class="type">byte</span>)i;</span><br><span class="line">System.out.println(b);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出 -128</span></span><br></pre></td></tr></table></figure><p>为什么结果是-128？精度丢失了！</p><ul><li>int 类型的128表示：00000000 00000000 00000000 10000000</li><li>byte类型转换后表示：xxxxxxxx xxxxxxxx xxxxxxxx 10000000 &#x3D;&gt; -128</li></ul><h3 id="数据类型自动提升"><a href="#数据类型自动提升" class="headerlink" title="数据类型自动提升"></a>数据类型自动提升</h3><p>在参与运算时（也可以位于表达式中时，自增自减除外），所有的byte型、short型和char的值将被提升到int型：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">105</span>;</span><br><span class="line">b = b + <span class="number">1</span>;   <span class="comment">//报错！</span></span><br><span class="line">System.out.println(b);</span><br></pre></td></tr></table></figure><p>这个特性是由 <strong>Java虚拟机规范</strong> 定义的，也是为了提高运行的效率。其他的特性还有：</p><ul><li>如果一个操作数是long型，计算结果就是long型</li><li>如果一个操作数是float型，计算结果就是float型</li><li>如果一个操作数是double型，计算结果就是double型</li></ul><hr><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="赋值和算术运算符"><a href="#赋值和算术运算符" class="headerlink" title="赋值和算术运算符"></a>赋值和算术运算符</h3><p>赋值运算符<code>=</code>是最常用的运算符，其实就是将我们等号右边的结果，传递给等号左边的变量，例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span> + <span class="number">8</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">5</span> * <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>算术运算符也就是我们在小学阶段学习的<code>+</code> <code>-</code> <code>*</code> <code>/</code> <code>%</code>，分别代表加减乘除还有取余，例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a * b;</span><br><span class="line"><span class="comment">//结果为6</span></span><br></pre></td></tr></table></figure><p>需要注意的是，<code>+</code>还可以用作字符串连接符使用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;lbw&quot;</span> + <span class="string">&quot;nb&quot;</span>);  <span class="comment">//lbwnb</span></span><br></pre></td></tr></table></figure><p>当然，字符串可以直接连接其他类型，但是会全部当做字符串处理：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">7</span>, b = <span class="number">15</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;lbw&quot;</span> + a + b); <span class="comment">//lbw715</span></span><br></pre></td></tr></table></figure><p>算术运算符还包括<code>++</code>和<code>--</code>也就是自增和自减，以自增为例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">a++;</span><br><span class="line">System.out.println(a); <span class="comment">//输出为11</span></span><br></pre></td></tr></table></figure><p>自增自减运算符放在变量的前后的返回值是有区别的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">System.out.println(a++);  <span class="comment">//10 （先返回值，再自增）</span></span><br><span class="line">System.out.println(a);   <span class="comment">//11</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">System.out.println(++a);  <span class="comment">//11 （先自增，再返回值）</span></span><br><span class="line">System.out.println(a);  <span class="comment">//11</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">System.out.println(b+++a++);  <span class="comment">//猜猜看结果是多少</span></span><br></pre></td></tr></table></figure><p>为了使得代码更简洁，你还可以使用扩展的赋值运算符，包括<code>+=</code>、<code>-=</code>、<code>/=</code>、<code>*=</code>、<code>%=</code>，和自增自减类似，先执行运算，再返回结果，同时自身改变：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">System.out.println(a += <span class="number">2</span>);  <span class="comment">//等价于 a = a + 2</span></span><br></pre></td></tr></table></figure><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>关系运算符的结果只能是布尔类型，也就是要么为真要么为假，关系运算符包括：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; &lt; == <span class="comment">//大于小于等于</span></span><br><span class="line">&gt;= &lt;=  !=  <span class="comment">//大于等于，小于等于，不等于</span></span><br></pre></td></tr></table></figure><p>关系运算符一般只用于基本类型的比较，运算结果只能是boolean：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">x</span> <span class="operator">=</span> a &gt; b;</span><br><span class="line">System.out.println(x);</span><br><span class="line"><span class="comment">//结果为 true</span></span><br></pre></td></tr></table></figure><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>逻辑运算符两边只能是boolean类型或是关系&#x2F;逻辑运算表达式，返回值只能是boolean类型！逻辑运算符包括：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&amp;&amp; <span class="comment">//与运算，要求两边同时为true才能返回true</span></span><br><span class="line">|| <span class="comment">//或运算，要求两边至少要有一个为true才能返回true</span></span><br><span class="line">! <span class="comment">//非运算，一般放在表达式最前面，表达式用括号扩起来，表示对表达式的结果进行反转</span></span><br></pre></td></tr></table></figure><p>实际案例来看看：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">x</span> <span class="operator">=</span> a &gt; b &amp;&amp; a &lt; b;  <span class="comment">//怎么可能同时满足呢</span></span><br><span class="line">System.out.println(x);   <span class="comment">//false</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">x</span> <span class="operator">=</span> a &gt; b || a &lt;= b;  <span class="comment">//一定有一个满足！</span></span><br><span class="line">System.out.println(x);   <span class="comment">//true</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">x</span> <span class="operator">=</span> !(a &gt; b); <span class="comment">//对结果进行反转，本来应该是true</span></span><br><span class="line">System.out.println(x); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&amp; <span class="comment">//按位与，注意，返回的是运算后的同类型值，不是boolean！</span></span><br><span class="line">| <span class="comment">//按位或</span></span><br><span class="line">^ <span class="comment">//按位异或 0 ^ 0 = 0</span></span><br><span class="line">~ <span class="comment">//按位非</span></span><br></pre></td></tr></table></figure><p>按位运算实际上是根据值的二进制编码来计算结果，例如按位与，以4bit为例：</p><p>0101 &amp; 0100 &#x3D; 0100 （只有同时为1对应位才得1）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">7</span>, b = <span class="number">15</span>;</span><br><span class="line">System.out.println(a &amp; b); <span class="comment">//结果为7</span></span><br></pre></td></tr></table></figure><h3 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h3><p>三目运算符其实是为了简化代码而生，可以根据条件是否满足来决定返回值，格式如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">7</span>, b = <span class="number">15</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> a &gt; b ? <span class="string">&quot;行&quot;</span> : <span class="string">&quot;不行&quot;</span>;  <span class="comment">// 判断条件(只能是boolean,或返回boolean的表达式) ? 满足的返回值 : 不满足的返回值 </span></span><br><span class="line">System.out.println(<span class="string">&quot;汉堡做的行不行？&quot;</span>+str);  <span class="comment">//汉堡做的行不行？不行</span></span><br></pre></td></tr></table></figure><p>理解三目运算符，就很容易理解后面的if-else语句了。</p><hr><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>我们的程序都是从上往下依次运行的，但是，仅仅是这样还不够，我们需要更加高级的控制语句来帮我进行更灵活的控制。比如，判断用户输入的数字，大于1则输出ok，小于1则输出no，这时我们就需要用到选择结构来帮助我们完成条件的判断和程序的分支走向。学习过C语言就很轻松！</p><h3 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h3><p>选择结构包含if和switch类型，选择结构能够帮助我们根据条件判断，再执行哪一块代码。</p><h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h4><p>就像上面所说，判断用户输入的数字，大于1则输出ok，小于1则输出no，要实现这种效果，我们首先可以采用if语句：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(判断条件)&#123;</span><br><span class="line">  <span class="comment">//判断成功执行的内容</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="comment">//判断失败执行的内容</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//if的内容执行完成后，后面的内容正常执行</span></span><br></pre></td></tr></table></figure><p>其中，<code>else</code>语句不是必须的。</p><p>现在，又来了一个新的需求，用户输入的是1打印ok，输入2，打印yes，其他打印no，那么这样就需要我们进行多种条件的判断了，当然if能进行多分支判断：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(判断条件<span class="number">1</span>)&#123;</span><br><span class="line">  <span class="comment">//判断成功执行的内容</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(判断条件<span class="number">2</span>)&#123;</span><br><span class="line">  <span class="comment">//再次判断，如果判断成功执行的内容</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="comment">//上面的都没成功，只能走这里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，<code>else</code>语句不是必须的。</p><p>现在，又来了一个新的需求，用户输入1之后，在判断用户下一次输入的是什么，如果是1，打印yes，不是就打印no，这样就可以用嵌套if了：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(判断条件<span class="number">1</span>)&#123;</span><br><span class="line">  <span class="comment">//前提是判断条件1要成功才能进来！</span></span><br><span class="line">  <span class="keyword">if</span>(判断条件<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="comment">//判断成功执行的内容</span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//判断失败执行的内容</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h4><p>我们不难发现，虽然<code>else-if</code>能解决多分支判断的问题，但是效率实在是太低了，多分支if采用的是逐级向下判断，显然费时费力，那么有没有一直更专业的解决多分支判断问题的东西呢？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(判断主体)&#123;</span><br><span class="line">  <span class="keyword">case</span> 值<span class="number">1</span>:</span><br><span class="line">    <span class="comment">//运行xxx</span></span><br><span class="line">    <span class="keyword">break</span>;  <span class="comment">//break用于跳出switch语句，不添加会导致程序继续向下运行！</span></span><br><span class="line">  <span class="keyword">case</span> 值<span class="number">2</span>:</span><br><span class="line">    <span class="comment">//运行xxx</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> 值<span class="number">3</span>:</span><br><span class="line">    <span class="comment">//运行xxx</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述语句中，只有判断主体等于case后面的值时，才会执行case中的语句，同时需要使用break来跳出switch语句，否则会继续向下运行！</p><p>为什么switch效率更高呢，因为switch采用二分思想进行查找（这也是为什么switch只能判断值相等的原因），能够更快地找到我们想要的结果！</p><h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><p>小明想向小红表白，于是他在屏幕上打印了520个 “我爱你”，我们用Java该如何实现呢？</p><h4 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h4><p>for语句是比较灵活的循环控制语句，一个for语句的定义如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始条件;循环条件;更新)&#123;</span><br><span class="line">  <span class="comment">//循环执行的内容</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//循环结束后，继续执行</span></span><br></pre></td></tr></table></figure><ul><li>初始条件：循环开始时的条件，一般用于定义控制循环的变量。</li><li>循环条件：每轮循环开始之前，进行一次判断，如果满足则继续，不满足则结束，要求为boolean变量或是boolean表达式。</li><li>更新：每轮循环结束后都会执行的内容，一般写增量表达式。</li></ul><p>初始条件、循环条件、更新条件不是缺一不可，甚至可以都缺！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">520</span>;i++)&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;我爱你&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">  <span class="comment">//这里的内容将会永远地进行下去！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>增强for循环在数组时再讲解！</p><h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><p>while循环和for循环类似，但是它更加的简单，只需要添加维持循环的判断条件即可！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(循环条件)&#123;</span><br><span class="line">  <span class="comment">//循环执行的内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和for一样，每次循环开始，当循环条件不满足时，自动退出！那么有时候我们希望先执行了我们的代码再去判断怎么办呢，我们可以使用do-while语句：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">  <span class="comment">//执行内容</span></span><br><span class="line">&#125;<span class="keyword">while</span>(循环条件);</span><br></pre></td></tr></table></figure><p>一定会先执行do里面的内容，再做判断！</p><p>思考：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//它们的性能谁更高？</span></span><br></pre></td></tr></table></figure><hr><h2 id="面向过程编程实战（基础-算法）"><a href="#面向过程编程实战（基础-算法）" class="headerlink" title="面向过程编程实战（基础+算法）"></a>面向过程编程实战（基础+算法）</h2><h3 id="打印九九乘法表"><a href="#打印九九乘法表" class="headerlink" title="打印九九乘法表"></a>打印九九乘法表</h3><p>简单：将九九乘法表打印到控制台。</p><h3 id="求1000以内的水仙花数"><a href="#求1000以内的水仙花数" class="headerlink" title="求1000以内的水仙花数"></a>求1000以内的水仙花数</h3><p>中等：打印1000以内所有满足水仙花的数，“水仙花数”是指一个三位数其各位数字的立方和等于该数本身，例如153是“水仙花数”，因为：153 &#x3D; 1^3 + 5^3 + 3^3</p><h3 id="青蛙跳台阶问题"><a href="#青蛙跳台阶问题" class="headerlink" title="青蛙跳台阶问题"></a>青蛙跳台阶问题</h3><p>困难：一共有n个台阶，一只青蛙每次只能跳一阶或是两阶，那么一共有多少种跳到顶端的方案？例如n&#x3D;2，那么一共有两种方案，一次性跳两阶或是每次跳一阶。</p><p>动态规划：其实，就是利用，上次得到的结果，给下一次作参考，下一次就能利用上次的结果快速得到结果，依次类推</p><hr>]]></content>
      
      
      <categories>
          
          <category> JAVASE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见的算法</title>
      <link href="/2022/10/13/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%AE%97%E6%B3%95/"/>
      <url>/2022/10/13/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="常见算法"><a href="#常见算法" class="headerlink" title="常见算法"></a>常见算法</h1><h2 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h2><h3 id="基本查找"><a href="#基本查找" class="headerlink" title="基本查找"></a>基本查找</h3><p>基本查找&#x2F;顺序查找</p><p>核心：从0索引开始挨个查找</p><p>需求：定义一个方法利用基本查找，查询某个元素是否存在</p><p>数据如下：{131,,127,147,81,103,23,7,79}</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">131</span>,<span class="number">127</span>,<span class="number">147</span>,<span class="number">81</span>,<span class="number">103</span>,<span class="number">23</span>,<span class="number">7</span>,<span class="number">79</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">81</span>;</span><br><span class="line">        System.out.println(basicSearch(arr,number));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//需要的参数</span></span><br><span class="line">    <span class="comment">//1.数组</span></span><br><span class="line">    <span class="comment">//2.要查找的元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">basicSearch</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> number)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] == number)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二分查找-x2F-折半查找"><a href="#二分查找-x2F-折半查找" class="headerlink" title="二分查找&#x2F;折半查找"></a>二分查找&#x2F;折半查找</h3><p>前提条件：数组中的数据必须是有序的</p><p>核心逻辑：每次排除一半的查找范围</p><p>1.min和max表示当前要查找的范围</p><p>2.mid是在min和max中间的</p><p>3.如果要查找的元素在mid的左边，缩小范围时，min不变，max等于mid减1</p><p>4.如果要查找的元素在mid的右边，缩小范围时，max不变，min等于mid加1</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> heima;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">7</span>,<span class="number">23</span>,<span class="number">79</span>,<span class="number">81</span>,<span class="number">103</span>,<span class="number">127</span>,<span class="number">131</span>,<span class="number">147</span>&#125;;</span><br><span class="line">        System.out.println(binarySeach(arr,<span class="number">81</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySeach</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> number)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//利用循环查找需要查找的数据</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (min &gt; max) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找到中间的位置</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (min + max) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//拿着mid的数据在数组中进行比较</span></span><br><span class="line">            <span class="keyword">if</span> (arr[mid] &gt; number) &#123;</span><br><span class="line">                <span class="comment">//大于</span></span><br><span class="line">                max = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; number) &#123;</span><br><span class="line">                <span class="comment">//小于</span></span><br><span class="line">                min = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二分查找改进（插值查找）"><a href="#二分查找改进（插值查找）" class="headerlink" title="二分查找改进（插值查找）"></a>二分查找改进（插值查找）</h4><p><img src="https://blog-1258155859.cos.ap-guangzhou.myqcloud.com/imgSnipaste_2022-08-19_19-56-52.png"></p><h3 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h3><p>分块原则1：前一块中的最大一块，小于后一块中所有的数据（块内无序，块间有序）</p><p>分块原则2：块的数量一般等于数字的个数开根号。比如：16个数字一般分为4块左右</p><p>核心思路：先确定要查找的元素在哪一块，然后在块内挨个查找</p><p><img src="https://blog-1258155859.cos.ap-guangzhou.myqcloud.com/imgSnipaste_2022-08-22_22-40-33.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> heima;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//分块查找</span></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">16</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">12</span>, <span class="number">21</span>,<span class="number">18</span>,</span><br><span class="line">                    <span class="number">32</span>,<span class="number">23</span>,<span class="number">37</span>,<span class="number">26</span>,<span class="number">45</span>,<span class="number">34</span>,</span><br><span class="line">                    <span class="number">50</span>,<span class="number">48</span>,<span class="number">61</span>,<span class="number">52</span>,<span class="number">73</span>,<span class="number">66</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建三个块的对象</span></span><br><span class="line">        <span class="type">Block</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Block</span>(<span class="number">21</span>,<span class="number">0</span>,<span class="number">5</span>);</span><br><span class="line">        <span class="type">Block</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Block</span>(<span class="number">45</span>,<span class="number">6</span>,<span class="number">11</span>);</span><br><span class="line">        <span class="type">Block</span> <span class="variable">b3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Block</span>(<span class="number">73</span>,<span class="number">12</span>,<span class="number">17</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义数组管理者三个对象（索引表）</span></span><br><span class="line">        Block[] blockArr = &#123;b1,b2,b3&#125;;</span><br><span class="line">        <span class="comment">//定义一个需要查找的数据</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">37</span>;</span><br><span class="line">        <span class="comment">//调用方法，传递索引表，数组，要查找的元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> getIndex(blockArr,arr,number);</span><br><span class="line">        <span class="comment">//打印</span></span><br><span class="line">        System.out.println(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getIndex</span><span class="params">(Block[] blockArr, <span class="type">int</span>[] arr, <span class="type">int</span> number)</span> &#123;</span><br><span class="line">        <span class="comment">//1.确定number在那一块</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">indexBlock</span> <span class="operator">=</span> findIndexBlock(blockArr,number);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(indexBlock == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取这一块的开始索引，结束索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">startIndex</span> <span class="operator">=</span> blockArr[indexBlock].getStartIndex();</span><br><span class="line">        <span class="type">int</span> <span class="variable">endIndex</span> <span class="operator">=</span> blockArr[indexBlock].getEndIndex();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex;i &lt;= endIndex;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] == number)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个方法用来确定number在哪个块中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findIndexBlock</span><span class="params">(Block[] blockArr,<span class="type">int</span> number)</span>&#123;</span><br><span class="line">        <span class="comment">//Block b1 = new Block(21,0,5);</span></span><br><span class="line">        <span class="comment">//Block b2 = new Block(45,6,11);</span></span><br><span class="line">        <span class="comment">//Block b3 = new Block(73,12,17);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//从0索引开始遍历blockArr，如果number小于max，那么就表示number就在这个表中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; blockArr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(number &lt;= blockArr[i].getMax())&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Block</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> max;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> startIndex;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> endIndex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Block</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Block</span><span class="params">(<span class="type">int</span> max, <span class="type">int</span> startIndex, <span class="type">int</span> endIndex)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.max = max;</span><br><span class="line">        <span class="built_in">this</span>.startIndex = startIndex;</span><br><span class="line">        <span class="built_in">this</span>.endIndex = endIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMax</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMax</span><span class="params">(<span class="type">int</span> max)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.max = max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getStartIndex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> startIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStartIndex</span><span class="params">(<span class="type">int</span> startIndex)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.startIndex = startIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getEndIndex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> endIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEndIndex</span><span class="params">(<span class="type">int</span> endIndex)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.endIndex = endIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>扩展的分块查找（无规律的数据）</p><p><img src="https://blog-1258155859.cos.ap-guangzhou.myqcloud.com/imgSnipaste_2022-08-22_23-11-35.png"></p><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序：相邻的数据两两比较，小的放前面，大的放后面</p><p>1.第一轮循环结束，最大值已经找到，在数组的最右边</p><p>2.第二轮循环只要在剩下的元素找最大值就可以了</p><p>3.如果数组中有n个数据，总共我们只要执行n-1轮代码就可以了</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> heima;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">D</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr.length- <span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j] &gt; arr[j + <span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.print(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>选择排序：从0索引开始，拿着每一个索引上的元素跟后面的元素依次比较，小的放前面，大的放后面，以此类推</p><p>1.从0索引开始，跟后面的元素一一比较</p><p>2.小的放前面，大的放后面</p><p>3.第一轮循环结束后，最小的数据已经确定</p><p>4.第二轮循环从1索引开始以此类推</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> heima;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i] &gt; arr[j])&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">                    arr[i] = arr[j];</span><br><span class="line">                    arr[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.print(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>插入排序：将0索引的元素到N索引的元素看做是有序的，把N+1索引的元素放到最后一个当成是无序的。遍历无序的数据，将遍历到的元素插入到有序序列中适当的位置，如遇到相同的数据，插在后面</p><p>N的</p><p>范围：0~最大索引</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> heima;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">F</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">3</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.找到无序的那一组是从哪个索引开始的</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">startIndex</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt; arr[i + <span class="number">1</span>])&#123;</span><br><span class="line">                startIndex = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.遍历从startIndex开始到最后一个元素，依次得到无序数据中的每一个元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">//记录当前要插入数据的索引</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; arr[j] &lt; arr[j - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">                arr[j - <span class="number">1</span>] = temp;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.print(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h3><p>递归指的是方法中调用方法本身的现象</p><p>递归方法的作用：把一个赋值的问题层层转化为一个与原问题相似的规模较小的问题来求解</p><p>书写递归的两个核心：</p><ul><li>找出口：什么时候不再调用方法</li><li>找规则：如何把大问题变成规模较小的问题</li></ul><p>递归求1~100之间的和</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> heima;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">G</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(getSum(<span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> number)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(number == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> number + getSum(number - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>递归求阶乘</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> heima;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">H</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(getFactorialRecursion(<span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getFactorialRecursion</span><span class="params">(<span class="type">int</span> number)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(number == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> number * getFactorialRecursion(number - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>第一轮：把0索引的数字作为基准数，确定基准数在数组中正确的位置。比基准数小的全部在左边，比基准数大的全部在右边</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> heima;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">I</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">6</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">8</span>&#125;;</span><br><span class="line"></span><br><span class="line">        quickSort(arr,<span class="number">0</span>,arr.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr.length;i++)&#123;</span><br><span class="line">            System.out.print(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//参数一：需要排序的数组</span></span><br><span class="line">    <span class="comment">//参数二、需要排序数组的起始索引</span></span><br><span class="line">    <span class="comment">//参数三、需要排序数组的结束索引</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="comment">//定义两个变量记录要查找的范围</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> j;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//递归的出口</span></span><br><span class="line">        <span class="keyword">if</span>(start &gt; end)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录基准数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">baseNumber</span> <span class="operator">=</span> arr[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//利用循环找到要交换的数字</span></span><br><span class="line">        <span class="keyword">while</span>(start != end)&#123;</span><br><span class="line">            <span class="comment">//利用end，从后往前找，找比基准数小的数字</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(end &lt;= start || arr[end] &lt; baseNumber)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                end--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//利用start，从前往后找，找比基准数大的数字</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(end &lt;= start || arr[start] &gt; baseNumber)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//把end和start指向的元素进行交换</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[start];</span><br><span class="line">            arr[start] = arr[end];</span><br><span class="line">            arr[end] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当start和end指向同一个元素的时候，那么上面的循环就会结束</span></span><br><span class="line">        <span class="comment">//表示已经找到了基准数在数组中应存入的位置</span></span><br><span class="line">        <span class="comment">//基准数归位</span></span><br><span class="line">        <span class="comment">//就是拿着这个范围中的第一个数字，跟start指向的元素进行交换</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[start];</span><br><span class="line">        arr[start] = temp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//确定6左边的范围，重复刚刚的事情</span></span><br><span class="line">        quickSort(arr,i,start - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//确定6右边的范围，重复刚刚的事情</span></span><br><span class="line">        quickSort(arr,start + <span class="number">1</span>,j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1.冒泡排序</p><ul><li>相邻的元素两两比较，小的放前面，大的放后面</li></ul><p>2.选择排序</p><ul><li>从0索引开始，拿着每一个索引上的元素跟后面的元素依次比较，小的放前面，大的放后面</li></ul><p>3.插入排序</p><ul><li>将数组分为有序和无序两组，遍历无序数据，将元素插入有序序列中即可</li></ul><p>4.快速排序</p><ul><li>将排序范围中的第一个数字作为基准数，再定义两个变量start和end</li><li>start从前往后找比基准数大的，end从后往前找比基准数小的</li><li>找到之后交换start和end指向的元素，并稀罕这一过程，直到start个end处于同一个位置，该位置是基准数应存入的位置，再让基准数归位</li><li>归位后的效果：基准数左边的，比基准数小，基准数右边的，比基准数大</li></ul><h1 id="综合练习"><a href="#综合练习" class="headerlink" title="综合练习"></a>综合练习</h1><h2 id="不死神兔"><a href="#不死神兔" class="headerlink" title="不死神兔"></a>不死神兔</h2><p>有一个很有名的数学逻辑题叫做不死神兔问题，有一对兔子，从出生后第三个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一队兔子，假如兔子都不死，问第十二个月的兔子对数为多少</p><p>特点：从第三个数据开始，是前两个数据的和（斐波那契数列）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> heima;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">one</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span> [<span class="number">12</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        arr[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = arr[i - <span class="number">1</span>] + arr[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(arr[<span class="number">11</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="猴吃桃子"><a href="#猴吃桃子" class="headerlink" title="猴吃桃子"></a>猴吃桃子</h2><p>有一堆桃子，第一只猴子吃了其中的一半，并多吃了一个，以后每天猴子都吃当前剩下来的一半，然后再多吃一个，第十天的时候（还没吃），发现只剩下一个桃子了，请问，最初总共多少个桃子</p><p>day10： 1</p><p>day9： （day10 + 1） *  2 &#x3D; 4</p><p>day8：（day9 + 1）* 2 &#x3D; 10</p><p>出口：day &#x3D;&#x3D; 10 剩下1</p><p>规律：每一天的桃子数量都是最后一天数量加1乘2</p><p>反向递归</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> heima;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">one</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(getCount(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">(<span class="type">int</span> day)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(day &lt;= <span class="number">0</span> || day &gt;= <span class="number">11</span>)&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;当前时间错误&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归出口</span></span><br><span class="line">        <span class="keyword">if</span>(day == <span class="number">10</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (getCount(day + <span class="number">1</span>) + <span class="number">1</span>) * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
